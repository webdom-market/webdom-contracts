#include "../global_imports/all_imports.fc";
#include "constants.fc";


const int tons::MIN_TON_FOR_STORAGE = 44000000;


global int   storage::state;
global int   storage::is_deferred;

global int   storage::start_time;
global int   storage::end_time;
global int   storage::last_domain_renewal_time;

global int   storage::last_bid_value;
global int   storage::last_bid_time;
global slice storage::last_bidder_address;

global cell  storage::outbid_notification;
global cell  storage::payout_notification;

global int   storage::hot_until;        
global int   storage::colored_until;

global slice storage::jetton_wallet_address;

global cell  storage::const_cell;

global slice storage::domain_address;
global slice storage::seller_address;
global slice storage::jetton_minter_address;

global int   storage::min_bid_value;
global int   storage::max_bid_value;
global int   storage::min_bid_increment;
global int   storage::time_increment;

global int   storage::commission_factor;
global int   storage::max_commission;


() load_data() impure inline_ref {
    slice ds = get_data().begin_parse();
    storage::state                     = ds~load_uint(2);   
    storage::is_deferred               = ds~load_int(1);

    storage::start_time                = ds~load_uint(32);
    storage::end_time                  = ds~load_uint(32);
    storage::last_domain_renewal_time  = ds~load_uint(32);

    storage::last_bid_value            = ds~load_coins();
    storage::last_bid_time             = ds~load_uint(32);
    storage::last_bidder_address       = ds~load_msg_addr();

    storage::outbid_notification       = ds~load_ref();
    storage::payout_notification       = ds~load_ref();

    storage::hot_until                 = ds~load_uint(32);
    storage::colored_until             = ds~load_uint(32);

    storage::jetton_wallet_address    = ds~load_msg_addr();
    storage::const_cell               = ds~load_ref();
    ds.end_parse();

    slice ccs = storage::const_cell.begin_parse();
    storage::domain_address            = ccs~load_msg_addr();
    storage::seller_address            = ccs~load_msg_addr();
    storage::jetton_minter_address     = ccs~load_msg_addr();

    slice ccs2 = ccs~load_ref().begin_parse();
    ccs.end_parse();

    storage::min_bid_value             = ccs2~load_coins();   ;; less than 68 bits
    storage::max_bid_value             = ccs2~load_coins();   ;; less than 68 bits
    storage::min_bid_increment         = ccs2~load_uint(12);
    storage::time_increment            = ccs2~load_uint(32);

    storage::commission_factor         = ccs2~load_uint(16);
    storage::max_commission            = ccs2~load_coins();
    ccs2.end_parse();
}


#include "../global_imports/admin_functions.fc";  
#include "../global_imports/handle_promotion.fc";


() save_data() impure inline_ref {
    set_data(
        begin_cell()
            .store_uint(storage::state, 2)
            .store_int(storage::is_deferred, 1)
            .store_uint(storage::start_time, 32)
            .store_uint(storage::end_time, 32)
            .store_uint(storage::last_domain_renewal_time, 32)
            .store_coins(storage::last_bid_value)
            .store_uint(storage::last_bid_time, 32)
            .store_slice(storage::last_bidder_address)
            .store_ref(storage::outbid_notification)
            .store_ref(storage::payout_notification)
            .store_uint(storage::hot_until, 32)
            .store_uint(storage::colored_until, 32)
            .store_slice(storage::jetton_wallet_address)
            .store_ref(storage::const_cell)
        .end_cell()
    );
}

() end_auction(int query_id) impure inline {
    int commission = 0;
    if (storage::commission_factor) {
        commission = min(muldiv(storage::last_bid_value, storage::commission_factor, COMMISSION_DIVIDER), storage::max_commission);
        ;; send marketplace commission
        send_jettons(query_id, commission, MARKETPLACE_ADDRESS, storage::last_bidder_address, storage::jetton_wallet_address, tons::JETTON_TRANSFER + tons::NOTIFY_MARKETPLACE,
                        mode::SIMPLE, tons::NOTIFY_MARKETPLACE, MARKETPLACE_COMMISSION_NOTIFICATION());
    }
    ;; send seller payout
    send_jettons(query_id, storage::last_bid_value - commission, storage::seller_address, storage::seller_address, storage::jetton_wallet_address,
                 tons::JETTON_TRANSFER, mode::SIMPLE, 1, storage::payout_notification);
    
    transfer_nft(query_id, storage::domain_address, storage::last_bidder_address, 
                 storage::last_bidder_address, 0, mode::CARRY_REMAINING_BALANCE, tons::PURCHASE_NOTIFICATION, BUYER_NOTIFICATION());  ;; domain transfer

    storage::state = state::COMPLETED;
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    if (flags & 1) {  ;; bounced messages
        return ();
    }
    force_same_workchain(sender_address);

    load_data();

    int op = 0;
    int query_id = 0;
    if (in_msg_body.slice_bits()) {
        op = in_msg_body~load_uint(32);
    }
    if (op != 0) {
        query_id = in_msg_body~load_uint(64);
    }
    elseif (equal_slices(in_msg_body, msg::CANCEL_MESSAGE) | equal_slices(in_msg_body, msg::STOP_AUCTION_MESSAGE)) {
        op = op::STOP_AUCTION;
    }

    handle_admin_message(op, sender_address, in_msg_body, msg_value, storage::state != state::ACTIVE, storage::state != state::ACTIVE);
    int now_time = now();

    ;; Fill up balance
    if (op == op::FILL_UP_BALANCE) {
        if (storage::state == state::UNINIT) {
            throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, MARKETPLACE_ADDRESS));
            get_jetton_wallet_address(storage::jetton_minter_address, mode::CARRY_REMAINING_GAS);
            return ();
        }
        return ();
    }

    if (op == op::TAKE_WALLET_ADDRESS) {
        throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::jetton_minter_address));
        throw_unless(exc::ALREADY_DEPLOYED, storage::state == state::UNINIT);
        storage::jetton_wallet_address = in_msg_body~load_msg_addr();
        storage::state = state::ACTIVE;
        save_data();
        return ();
    }

    ;; Place a bid
    if (op == op::TRANSFER_NOTIFICATION) {
        int   transferred_jettons = in_msg_body~load_coins();
        slice from_address        = in_msg_body~load_msg_addr();

        ;; if jettons were received by dedust swap
        slice payload = in_msg_body~load_int(1) ? in_msg_body~load_ref().begin_parse() : in_msg_body;
        if (slice_bits(payload) == 267) {
            from_address = payload~load_msg_addr();
        }
        
        try {
            throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::jetton_wallet_address));
            if (storage::is_deferred & (now_time < storage::start_time)) {
                storage::is_deferred = false;
                storage::end_time = storage::end_time - storage::start_time + now_time;
                storage::start_time = now_time;
            }
            else {
                throw_unless(exc::DEAL_NOT_ACTIVE, (now_time >= storage::start_time) & (now_time < storage::end_time) & (storage::state == state::ACTIVE));
            }
            int required_gas = tons::END_JETTON_AUCTION;
            if (transferred_jettons > storage::max_bid_value) {
                required_gas += tons::JETTON_TRANSFER;
            }
            throw_unless(exc::OUT_OF_GAS, msg_value >= required_gas);

            int next_min_bid_value = max(max(storage::last_bid_value, storage::min_bid_value),
                                        muldiv(storage::last_bid_value, storage::min_bid_increment, BID_INCREMENT_DIVIDER));
            throw_unless(exc::BID_TOO_LOW, transferred_jettons >= next_min_bid_value);
            
            if (storage::end_time <= now_time + storage::time_increment) {
                storage::end_time = now_time + storage::time_increment;
            }
            if (now_time - storage::last_domain_renewal_time >= ONE_YEAR - max(storage::time_increment * 2, ONE_DAY * 7)) {
                storage::last_domain_renewal_time = now_time;
                send_cell_message(storage::domain_address, tons::RENEW_DOMAIN, null(), mode::PAY_FEES_SEPARATELY);  ;; prevent domain expiration
            }

            if (storage::last_bid_value != 0) {
                send_jettons(query_id, storage::last_bid_value, storage::last_bidder_address, storage::last_bidder_address, storage::jetton_wallet_address, 
                             my_balance - msg_value - tons::MIN_TON_FOR_STORAGE, mode::SIMPLE, 1, storage::outbid_notification);  ;; return the previous bid
            }

            storage::last_bid_time = now_time;
            storage::last_bidder_address = from_address;
            
            if (transferred_jettons >= storage::max_bid_value) {
                if (transferred_jettons > storage::max_bid_value) {
                    send_jettons(query_id, transferred_jettons - storage::max_bid_value, from_address, from_address, storage::jetton_wallet_address, 
                                 tons::JETTON_TRANSFER, mode::SIMPLE, 1, EXCESSES_NOTIFICATION());
                }
                storage::last_bid_value = storage::max_bid_value;
                storage::end_time = now_time;
                
                end_auction(query_id);
                save_data();
                return ();
            }
            else {
                send_message_with_comment(from_address, tons::JETTON_TRANSFER, "Bid placed successfully", mode::SIMPLE);
            }
            storage::last_bid_value = transferred_jettons;
            save_data();
            return ();
        } 
        catch (_, n) { ;; if something went wrong contract tries to return jettons back with corresponding error code as a comment
            send_jettons(query_id, transferred_jettons, from_address, from_address, sender_address, 0, mode::CARRY_REMAINING_GAS,
                           1, payload_with_comment("Error. Code ").store_number10(n).end_cell());  
            
            commit();
            throw(n);
            
            return ();
        }
    }

    throw_unless(exc::DEAL_NOT_ACTIVE, storage::state == state::ACTIVE);

    ;; Handle auction ending
    if (op == op::STOP_AUCTION) {
        if (storage::last_bid_value == 0) {  ;; Cancel auction if it hasn't started yet
            throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::seller_address));
            transfer_nft(query_id, storage::domain_address, storage::seller_address, storage::seller_address,
                        0, mode::CARRY_REMAINING_BALANCE, 1, AUCTION_CANCEL_NOTIFICATION());
            storage::state = state::CANCELLED;
            storage::end_time = now_time;
        }
        elseif (storage::end_time <= now_time) {  ;; End auction if it is over
            throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::seller_address) | equal_slices(sender_address, storage::last_bidder_address));
            end_auction(query_id);
        }
        else {
            throw(exc::AUCTION_NOT_ENDED);
        }

        save_data();
        return ();
    }

    ;; Renew the domain
    if (op == op::RENEW_DOMAIN) {
        raw_reserve(storage_fees(), 4);
        send_cell_message(storage::domain_address, tons::RENEW_DOMAIN, null(), mode::PAY_FEES_SEPARATELY);
        send_excess(sender_address, query_id, 0, mode::CARRY_REMAINING_BALANCE);

        storage::last_domain_renewal_time = now_time;
        save_data();
        return ();
    }
    
    if ((op == op::MAKE_COLORED) | (op == op::MAKE_HOT)) {
        int promotion_until = in_msg_body~load_uint(32);
        handle_promotion(promotion_until, op, query_id, sender_address);
        save_data();
        return ();
    }

    throw(exc::UNSUPPORTED_OP);
}


() recv_external(slice in_msg_body) impure {
    load_data();

    throw_if(exc::DEAL_NOT_ACTIVE, storage::state != state::ACTIVE);

    if (now() >= storage::end_time) {
        throw_if(exc::UNSUPPORTED_OP, in_msg_body~load_uint(32) != op::CANCEL_DEAL);
        accept_message();
        if (storage::last_bid_value == 0) {  ;; No one participated in the auction
            transfer_nft(in_msg_body~load_uint(64), storage::domain_address, storage::seller_address, 
                         storage::seller_address, 0, mode::CARRY_REMAINING_BALANCE, 1, AUCTION_CANCEL_NOTIFICATION());
            storage::state = state::CANCELLED;
        }
        else {  ;; Auction finished successfully
            end_auction(in_msg_body~load_uint(64));
        }

        save_data();
        return ();
    }

    throw(0xfffe);
}


;; Get methods

(slice, cell, int, int, int, int, int, int, int, int, slice, int,
 int, int, int, int, cell, cell, int, slice, int, int, int, slice, int) get_storage_data() method_id {
    load_data();
    cell domains_dict = new_dict();
    domains_dict~dict_set(267, storage::domain_address, BIT_TRUE_SLICE());

    return (
        storage::seller_address, 
        domains_dict, 
        1,
        1,
        storage::state, 
        storage::max_bid_value,
        storage::commission_factor,
        storage::start_time, 
        storage::last_domain_renewal_time,
        storage::end_time, 
        storage::last_bidder_address,

        storage::min_bid_value, 
        storage::min_bid_increment, 
        storage::time_increment, 

        storage::last_bid_value, 
        storage::last_bid_time, 

        storage::outbid_notification, 
        storage::payout_notification, 

        storage::max_commission,

        storage::jetton_wallet_address,

        storage::is_deferred & (now() < storage::start_time),

        storage::hot_until,
        storage::colored_until,

        storage::jetton_minter_address, 
        cell_hash(my_code())
    );
}


(int, int, int, slice, slice, slice, int, slice, int, slice, int, int, slice, int, int, int, int, int, int, int, int, int, slice, slice, int, int) get_auction_data_v4() method_id {
    load_data();

    if (storage::is_deferred & (now() < storage::start_time)) {
        storage::end_time = now() + storage::end_time - storage::start_time;
        storage::start_time = now();
    }

    return (
        storage::state != state::UNINIT,                 ;; Int1
        storage::state > state::ACTIVE,                  ;; Int1
        storage::end_time,                               ;; Uint32
        MARKETPLACE_ADDRESS,                             ;; MsgAddressStd
        storage::domain_address,                         ;; MsgAddressStd
        storage::seller_address,                         ;; MsgAddressStd
        storage::last_bid_value,                         ;; Coins
        storage::last_bidder_address,                    ;; MsgAddressStd
        (storage::min_bid_increment - 1000) / 10,        ;; Uint7
        MARKETPLACE_ADDRESS,                             ;; MsgAddressStd
        storage::commission_factor, COMMISSION_DIVIDER,  ;; Uint32, Uint32
        BURN_ADDRESS,                                    ;; MsgAddressStd
        0, 1,                                            ;; Uint32, Uint32
        storage::max_bid_value,                          ;; Coins
        storage::min_bid_value,                          ;; Coins
        storage::start_time,                             ;; Uint32
        storage::last_bid_time,                          ;; Uint32
        storage::state == state::CANCELLED,              ;; Int1
        storage::time_increment,                         ;; Uint17
        0,                                               ;; Uint64
        storage::jetton_wallet_address,                  ;; MsgAddressStd
        storage::jetton_minter_address,                  ;; MsgAddressStd
        0,                                               ;; Uint1
        0                                                ;; Uint256
    );
}
