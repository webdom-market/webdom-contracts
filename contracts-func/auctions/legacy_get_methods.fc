;; from https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/sources/nft-auction-v3r3.fc

(int, int, int, slice, slice, slice, int, slice, int, slice, int, int, slice, int, int, int, int, int, int, int, int, int) get_auction_data() method_id {
    load_data();
    if (storage::max_bid_value == MAX_COINS_VALUE) {
        storage::max_bid_value = 0;
    }
    if (storage::is_deferred & (now() < storage::start_time)) {
        storage::end_time = now() + storage::end_time - storage::start_time;
        storage::start_time = now();
    }


    return (
        storage::state != state::UNINIT,                 ;; Int1
        storage::state > state::ACTIVE,                  ;; Int1
        storage::end_time,                               ;; Uint32
        MARKETPLACE_ADDRESS,                             ;; MsgAddressStd
        storage::domain_address,                         ;; MsgAddressStd
        storage::seller_address,                         ;; MsgAddressStd
        storage::last_bid_value,                         ;; Coins
        storage::last_bidder_address,                    ;; MsgAddressStd
        (storage::min_bid_increment - 1000) / 10,        ;; Uint7
        MARKETPLACE_ADDRESS,                             ;; MsgAddressStd
        storage::commission_factor, COMMISSION_DIVIDER,  ;; Uint32, Uint32
        BURN_ADDRESS,                                    ;; MsgAddressStd
        0, 1,                                            ;; Uint32, Uint32
        storage::max_bid_value,                          ;; Coins
        storage::min_bid_value,                          ;; Coins
        storage::start_time,                             ;; Uint32
        storage::last_bid_time,                          ;; Uint32
        storage::state == state::CANCELLED,              ;; Int1
        storage::time_increment,                         ;; Uint17
        0                                                ;; Uint64
    );
}


;; from https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/sources/nft-auction/struct/get-met.func

(int, int) get_nft_owner() method_id {
    load_data();
    (int wc, int addr) = parse_std_addr(storage::seller_address);
    return (wc, addr);
}

(int, int) get_nft_addr() method_id {
    load_data();
    (int wc, int addr) = parse_std_addr(storage::domain_address);
    return (wc, addr);
}

(int, int) get_last_member() method_id {
    load_data();
    (int wc, int addr) = parse_std_addr(storage::last_bidder_address);
    return (wc, addr);
}

(int, int) get_mp_addr() method_id {
    (int wc, int addr) = parse_std_addr(MARKETPLACE_ADDRESS);
    return (wc, addr);
}

(int, int) get_mp_fee_addr() method_id {
    (int wc, int addr) = parse_std_addr(MARKETPLACE_ADDRESS);
    return (wc, addr);
}

(int, int) get_royalty_fee_addr() method_id {
    (int wc, int addr) = parse_std_addr(BURN_ADDRESS);
    return (wc, addr);
}

(int, int, int, int) get_fees_info() method_id {
    load_data();
    return (storage::commission_factor, COMMISSION_DIVIDER, 0, 1);
}

(int, int, int, int, int) get_bid_info() method_id {
    load_data();
    if (storage::is_deferred & (now() < storage::start_time)) {
        storage::end_time = now() + storage::end_time - storage::start_time;
        storage::start_time = now();
    }

    return (
            storage::min_bid_value, storage::max_bid_value, (storage::min_bid_increment - 1000) / 10,
            storage::last_bid_value, storage::end_time
    );
}

;; 1  2    3    4      5      6      7    8      9    10     11   12   13     14   15   16   17   18   19   20
(int, int, int, slice, slice, slice, int, slice, int, slice, int, int, slice, int, int, int, int, int, int, int) get_sale_data() method_id {
    load_data();
    if (storage::is_deferred & (now() < storage::start_time)) {
        storage::end_time = now() + storage::end_time - storage::start_time;
        storage::start_time = now();
    }


    return (
        0x415543, ;; 1 nft aucion ("AUC")
        storage::state > state::ACTIVE, ;; 2
        storage::end_time, ;; 3
        MARKETPLACE_ADDRESS, ;; 4
        storage::domain_address, ;; 5
        storage::seller_address, ;; 6
        storage::last_bid_value, ;; 7
        storage::last_bidder_address, ;; 8
        (storage::min_bid_increment - 1000) / 10, ;; 9
        MARKETPLACE_ADDRESS, ;; 10
        storage::commission_factor, COMMISSION_DIVIDER, ;; 11, 12
        BURN_ADDRESS, ;; 13
        0, 1, ;; 14, 15
        storage::max_bid_value, ;; 16
        storage::min_bid_value, ;; 17
        storage::start_time, ;; 18
        storage::last_bid_time, ;; 19
        storage::state == state::CANCELLED ;; 20
    );
}
