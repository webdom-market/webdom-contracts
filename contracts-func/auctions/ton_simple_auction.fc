#include "../global_imports/all_imports.fc";
#include "constants.fc";


const int tons::MIN_TON_FOR_STORAGE = 44000000;


global int   storage::state;  ;; 0 -> uninit, 1 -> active, 2 -> completed, 3 -> cancelled
global int   storage::is_deferred;

global int   storage::start_time;
global int   storage::end_time;
global int   storage::last_domain_renewal_time;

global int   storage::last_bid_value;
global int   storage::last_bid_time;
global slice storage::last_bidder_address;

global cell  storage::outbid_notification;
global cell  storage::payout_notification;

global int   storage::hot_until;        
global int   storage::colored_until;

global cell  storage::const_cell;

global slice storage::domain_address;
global slice storage::seller_address;

global int   storage::min_bid_value;
global int   storage::max_bid_value;
global int   storage::min_bid_increment;
global int   storage::time_increment;

global int   storage::commission_factor;
global int   storage::max_commission;


() load_data() impure inline_ref {
    slice ds = get_data().begin_parse();
    storage::state                     = ds~load_uint(2);
    storage::is_deferred              = ds~load_int(1);

    storage::start_time                = ds~load_uint(32);
    storage::end_time                  = ds~load_uint(32);
    storage::last_domain_renewal_time  = ds~load_uint(32);

    storage::last_bid_value            = ds~load_coins();
    storage::last_bid_time             = ds~load_uint(32);
    storage::last_bidder_address       = ds~load_msg_addr();

    storage::outbid_notification       = ds~load_ref();
    storage::payout_notification       = ds~load_ref();

    storage::hot_until                 = ds~load_uint(32);
    storage::colored_until             = ds~load_uint(32);

    storage::const_cell                = ds~load_ref();
    ds.end_parse();

    slice ccs = storage::const_cell.begin_parse();
    storage::domain_address            = ccs~load_msg_addr();
    storage::seller_address            = ccs~load_msg_addr();
    
    storage::min_bid_value             = ccs~load_coins();
    storage::max_bid_value             = ccs~load_coins();
    storage::min_bid_increment         = ccs~load_uint(12);
    storage::time_increment            = ccs~load_uint(32);

    storage::commission_factor         = ccs~load_uint(16);
    storage::max_commission            = ccs~load_coins();
    ccs.end_parse();
}


#include "../global_imports/admin_functions.fc";  
#include "../global_imports/handle_promotion.fc";

() save_data() impure inline_ref {
    set_data(
        begin_cell()
            .store_uint(storage::state, 2)
            .store_int(storage::is_deferred, 1)
            .store_uint(storage::start_time, 32)
            .store_uint(storage::end_time, 32)
            .store_uint(storage::last_domain_renewal_time, 32)
            .store_coins(storage::last_bid_value)
            .store_uint(storage::last_bid_time, 32)
            .store_slice(storage::last_bidder_address)
            .store_ref(storage::outbid_notification)
            .store_ref(storage::payout_notification)
            .store_uint(storage::hot_until, 32)
            .store_uint(storage::colored_until, 32)
            .store_ref(storage::const_cell)
        .end_cell()
    );
}

() end_auction(int query_id, int my_balance, int buyer_overpayment) impure inline {
    int commission = min(muldiv(storage::last_bid_value, storage::commission_factor, COMMISSION_DIVIDER), storage::max_commission);
    send_message_with_comment(MARKETPLACE_ADDRESS, commission, "Marketplace commission", mode::SIMPLE);  ;; marketplace commission 
    send_cell_message(storage::seller_address, my_balance - commission - buyer_overpayment,
                      storage::payout_notification, mode::SIMPLE);  ;; seller payout
    
    transfer_nft(query_id, storage::domain_address, storage::last_bidder_address, 
                 storage::last_bidder_address, 0, mode::CARRY_REMAINING_BALANCE, tons::PURCHASE_NOTIFICATION, BUYER_NOTIFICATION());  ;; domain transfer

    storage::state = state::COMPLETED;
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    if (flags & 1) {  ;; bounced messages
        return ();
    }
    force_same_workchain(sender_address);

    load_data();

    int op = 0;
    int query_id = 0;
    if (in_msg_body.slice_bits()) {
        op = in_msg_body~load_uint(32);
    }
    if (op != 0) {
        query_id = in_msg_body~load_uint(64);
    }
    elseif (equal_slices(in_msg_body, msg::CANCEL_MESSAGE) | equal_slices(in_msg_body, msg::STOP_AUCTION_MESSAGE)) {
        op = op::STOP_AUCTION;
    }

    handle_admin_message(op, sender_address, in_msg_body, msg_value, storage::state != state::ACTIVE, storage::state != state::ACTIVE);
    int now_time = now();

    ;; Fill up balance
    if (op == op::FILL_UP_BALANCE) {
        if (storage::state == state::UNINIT) {
            throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, MARKETPLACE_ADDRESS));
            storage::state = state::ACTIVE;
            save_data();
        }
        return ();
    }

    ;; Pay in any jettons via dedust swaps
    if (op == op::DEDUST_PAYOUT) {
        op = 0;
        sender_address = in_msg_body~load_maybe_ref().begin_parse();
    }
    
    return_tons_if_condition(sender_address, exc::DEAL_NOT_ACTIVE, storage::state != state::ACTIVE);

    ;; Place a bid
    if (op == 0) {
        if (storage::is_deferred & (now_time < storage::start_time)) {
            storage::is_deferred = false;
            storage::end_time = storage::end_time - storage::start_time + now_time;
            storage::start_time = now_time;
        }
        else {
            return_tons_if_condition(sender_address, exc::DEAL_NOT_ACTIVE, (now_time < storage::start_time) | (now_time >= storage::end_time));
        }
        int next_min_bid_value = max(max(storage::last_bid_value + tons::MIN_BID_INCREMENT, storage::min_bid_value),
                                     muldiv(storage::last_bid_value, storage::min_bid_increment, BID_INCREMENT_DIVIDER));
        int user_bid = msg_value - tons::END_TON_AUCTION - tons::NOTIFY_BIDDER;
        return_tons_if_condition(sender_address, exc::BID_TOO_LOW, user_bid < next_min_bid_value);
        
        if (storage::end_time <= now_time + storage::time_increment) {
            storage::end_time = now_time + storage::time_increment;
        }
        if (now_time - storage::last_domain_renewal_time >= ONE_YEAR - max(storage::time_increment * 2, ONE_DAY * 7)) {
            storage::last_domain_renewal_time = now_time;
            send_cell_message(storage::domain_address, tons::RENEW_DOMAIN, null(), mode::PAY_FEES_SEPARATELY);  ;; prevent domain expiration
        }

        if (storage::last_bid_value != 0) {
            send_cell_message(storage::last_bidder_address, my_balance - msg_value - tons::MIN_TON_FOR_STORAGE, storage::outbid_notification, mode::SIMPLE);  ;; return the previous bid
        }

        storage::last_bid_time = now_time;
        storage::last_bidder_address = sender_address;
        
        if (user_bid >= storage::max_bid_value) {
            my_balance = my_balance - storage::last_bid_value; ;;- tons::END_TON_AUCTION;
            storage::last_bid_value = storage::max_bid_value;
            storage::end_time = now_time;
            
            end_auction(query_id, msg_value + tons::MIN_TON_FOR_STORAGE, msg_value - storage::max_bid_value);
            save_data();
            return ();
        }
        else {
            cell payload = begin_cell().store_uint(0, 32).store_str_float(user_bid, ONE_TON).store_slice(" TON bid placed successfully").end_cell();
            send_cell_message(sender_address, tons::NOTIFY_BIDDER, payload, mode::SIMPLE);
        }
        storage::last_bid_value = user_bid;
        save_data();
        return ();
    }

    ;; Handle auction ending
    if (op == op::STOP_AUCTION) {
        if (storage::last_bid_value == 0) {  ;; Cancel auction if it hasn't started yet
            throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::seller_address));
            transfer_nft(query_id, storage::domain_address, storage::seller_address, storage::seller_address,
                        0, mode::CARRY_REMAINING_BALANCE, 1, AUCTION_CANCEL_NOTIFICATION());
            storage::state = state::CANCELLED;
            storage::end_time = now_time;
        }
        elseif (storage::end_time <= now_time) {  ;; End auction if it is over
            if (equal_slices(sender_address, storage::seller_address)) {
                msg_value = 0;
            }
            else {
                throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::last_bidder_address));
            }
            end_auction(query_id, my_balance, msg_value + tons::END_TON_AUCTION);
        }
        else {
            throw(exc::AUCTION_NOT_ENDED);
        }

        save_data();
        return ();
    }

    ;; Renew the domain
    if (op == op::RENEW_DOMAIN) {
        raw_reserve(storage_fees(), 4);
        send_cell_message(storage::domain_address, tons::RENEW_DOMAIN, null(), mode::PAY_FEES_SEPARATELY);
        send_excess(sender_address, query_id, 0, mode::CARRY_REMAINING_BALANCE);

        storage::last_domain_renewal_time = now_time;
        save_data();
        return ();
    }
    
    if ((op == op::MAKE_COLORED) | (op == op::MAKE_HOT)) {
        int promotion_until = in_msg_body~load_uint(32);
        handle_promotion(promotion_until, op, query_id, sender_address);
        save_data();
        return ();
    }

    raw_reserve(storage_fees(), 4);
    send_message_with_comment(sender_address, 0, "Unsupported op", mode::CARRY_REMAINING_BALANCE);
    commit();
    throw(exc::UNSUPPORTED_OP);
}


() recv_external(slice in_msg_body) impure {
    load_data();

    throw_if(exc::DEAL_NOT_ACTIVE, storage::state != state::ACTIVE);

    if (now() >= storage::end_time) {
        throw_if(exc::UNSUPPORTED_OP, in_msg_body~load_uint(32) != op::CANCEL_DEAL);
        accept_message();
        
        if (storage::last_bid_value == 0) {  ;; No one participated in the auction
            transfer_nft(in_msg_body~load_uint(64), storage::domain_address, storage::seller_address, 
                         storage::seller_address, 0, mode::CARRY_REMAINING_BALANCE, 1, AUCTION_CANCEL_NOTIFICATION());
            storage::state = state::CANCELLED;
        }
        else {  ;; Auction finished successfully
            int my_balance = pair_first(get_balance());
            end_auction(in_msg_body~load_uint(64), my_balance, tons::END_TON_AUCTION);
        }

        save_data();
        return ();
    }

    throw(0xfffe);
}


;; Get methods

(slice, cell, int, int, int, int, int, int, int, int, slice, int, int, int, int, int, cell, cell, int, int, int, int, slice, int) get_storage_data() method_id {
    load_data();
    
    cell domains_dict = new_dict();
    domains_dict~dict_set(267, storage::domain_address, BIT_TRUE_SLICE());

    return (
        storage::seller_address, 
        domains_dict, 
        1,
        1,
        storage::state, 
        storage::max_bid_value,
        storage::commission_factor,
        storage::start_time, 
        storage::last_domain_renewal_time,
        storage::end_time, 
        storage::last_bidder_address,

        storage::min_bid_value, 
        storage::min_bid_increment, 
        storage::time_increment, 

        storage::last_bid_value, 
        storage::last_bid_time, 

        storage::outbid_notification, 
        storage::payout_notification, 
        storage::max_commission,

        storage::is_deferred & (now() < storage::start_time),

        storage::hot_until,
        storage::colored_until,

        BURN_ADDRESS, 
        cell_hash(my_code())
    );
}

#include "legacy_get_methods.fc";