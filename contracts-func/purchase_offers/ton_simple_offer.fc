#include "../global_imports/all_imports.fc";
#include "constants.fc";

;; variables
global int   storage::state;
global int   storage::price;
global int   storage::commission;
global int   storage::valid_until;
global cell  storage::seller_address_cell;
global int   storage::cancelled_by_seller;
global int   storage::seller_price;
global int   storage::balance_to_reserve;

;; constants
global int   storage::created_at;
global slice storage::domain_address;
global slice storage::buyer_address;
global cell  storage::domain_name;
global cell  storage::public_key_cell;


() load_data() impure {
    slice ds = get_data().begin_parse();  ;; Bits = 267 + 124 + 2 + 124 + 32 + 32 + 267 + 1 + 1 = 850, Refs = 2
    storage::state               = ds~load_uint(2);
    storage::price               = ds~load_coins();
    storage::commission          = ds~load_coins();
    storage::valid_until         = ds~load_uint(32);
    storage::seller_address_cell = ds~load_maybe_ref();
    storage::cancelled_by_seller = ds~load_int(1);
    storage::seller_price        = ds~load_coins();

    storage::created_at          = ds~load_uint(32);
    storage::domain_address      = ds~load_msg_addr();
    storage::buyer_address       = ds~load_msg_addr();
    storage::domain_name         = ds~load_ref();
    storage::public_key_cell     = ds~load_maybe_ref();
    ds.end_parse();
    return ();
}


#include "../global_imports/admin_functions.fc";  


() save_data() impure inline {
    set_data(   
        begin_cell()
            .store_uint(storage::state, 2)
            .store_coins(storage::price)
            .store_coins(storage::commission)
            .store_uint(storage::valid_until, 32)
            .store_maybe_ref(storage::seller_address_cell)
            .store_int(storage::cancelled_by_seller, 1)
            .store_coins(storage::seller_price)

            .store_uint(storage::created_at, 32)
            .store_slice(storage::domain_address)
            .store_slice(storage::buyer_address)
            .store_ref(storage::domain_name)
            .store_maybe_ref(storage::public_key_cell)
        .end_cell()
    );
}


() accept_offer(slice seller_address, int seller_msg_value, int query_id) impure inline_ref {
    send_message_with_comment(MARKETPLACE_ADDRESS, storage::commission, msg::MARKETPLACE_COMMISSION_MESSAGE, mode::SIMPLE);     ;; marketplace commission 
    send_message_with_comment(seller_address, storage::price + seller_msg_value, "Offer accepted", mode::SIMPLE);  ;; seller payout
    transfer_nft(query_id, storage::domain_address, storage::buyer_address, storage::buyer_address, 0, mode::CARRY_REMAINING_BALANCE, tons::PURCHASE_NOTIFICATION, BUYER_NOTIFICATION());  ;; domain transfer
    
    storage::state = state::ACCEPTED;
    storage::valid_until = now();
    return ();
}


() cancel_offer(int seller_msg_value, slice cancellation_comment, int query_id) impure inline_ref {
    if (storage::seller_price) {
        transfer_nft(query_id, storage::domain_address, storage::seller_address_cell.begin_parse(), storage::buyer_address, tons::NFT_TRANSFER + seller_msg_value, mode::SIMPLE, 1, COUNTERPROPOSAL_REJECTED_NOTIFICATION());  
    }
    elseif (seller_msg_value > 0) {
        send_excess(storage::seller_address_cell.begin_parse(), query_id, seller_msg_value + tons::DECLINE_REWARD, mode::PAY_FEES_SEPARATELY);
    }

    storage::state = state::CANCELLED;
    storage::valid_until = min(storage::valid_until, now());
    save_data();
    
    send_message_with_comment(storage::buyer_address, 0, cancellation_comment, mode::CARRY_REMAINING_BALANCE);

    return ();
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    if (flags & 1) {  ;; bounced messages
        return ();
    }
    force_same_workchain(sender_address);

    load_data();

    int op = 0;
    int query_id = 0;
    if (in_msg_body.slice_bits()) {
        op = in_msg_body~load_uint(32);
    }
    if (op != 0) {
        query_id = in_msg_body~load_uint(64);
    }
    elseif (equal_slices(in_msg_body, msg::CANCEL_MESSAGE)) {
        op = op::CANCEL_DEAL;
    }

    if ((op == op::FILL_UP_BALANCE) & (equal_slices(sender_address, MARKETPLACE_ADDRESS))) {
        if(storage::state) {  ;; prevent accepting multiple deploy requests
            send_message_with_comment(storage::buyer_address, 0, "Offer has already been created", mode::CARRY_REMAINING_GAS);
            return ();
        }

        int balance_to_reserve = storage::price + storage::commission + tons::TON_SIMPLE_OFFER_RESERVE;
        if (my_balance > balance_to_reserve + tons::MIN_EXCESS) {
            raw_reserve(balance_to_reserve, 0);
            send_message_with_comment(storage::buyer_address, 0, "offer deployed", mode::CARRY_REMAINING_BALANCE);
        }
        storage::state = state::ACTIVE;
        save_data();
        return ();
    }

    ;; Fill up balance
    if (op == op::FILL_UP_BALANCE) {
        return ();
    }

    handle_admin_message(op, sender_address, in_msg_body, msg_value, storage::state != state::ACTIVE, storage::state != state::ACTIVE);

    int now_time = now();

    ;; Exchage domain for TON
    if (op == op::OWNERSHIP_ASSIGNED) {
        slice from_address = in_msg_body~load_msg_addr();
        
        slice payload = in_msg_body~load_int(1) ? in_msg_body~load_ref().begin_parse() : in_msg_body;
        int inner_op = payload.slice_bits() ? payload~load_uint(32) : 0;
            
        try {
            throw_unless(exc::DEAL_NOT_ACTIVE, (storage::valid_until > now_time) & (storage::state == state::ACTIVE));
            throw_unless(exc::INCORRECT_DOMAIN, equal_slices(sender_address, storage::domain_address));
            
            if (null?(storage::seller_address_cell)) {
                storage::seller_address_cell = begin_cell().store_slice(from_address).end_cell();
            }

            if (inner_op == 0) { 
                accept_offer(from_address, msg_value, query_id);
            }
            elseif (inner_op == op::COUNTERPROPOSE) {
                storage::seller_price = payload~load_coins();
                throw_unless(exc::INCORRECT_PRICE, storage::seller_price - storage::price >= tons::MIN_PRICE_CHANGE);
                
                int notify_buyer = payload~load_int(1);
                if (notify_buyer) {
                    send_message_with_comment(storage::buyer_address, tons::OFFER_NOTIFICATION, "You have received a counterproposal for your offer on webdom.market", mode::PAY_FEES_SEPARATELY);
                    my_balance -= tons::OFFER_NOTIFICATION;
                }
                ;; send_message_with_comment(MARKETPLACE_ADDRESS, tons::COUNTERPROPOSE_PRICE, msg::MARKETPLACE_COMMISSION_MESSAGE, mode::SIMPLE);     ;; marketplace commission 
                ;; my_balance -= tons::COUNTERPROPOSE_PRICE;
                int balance_to_reserve = storage::price + storage::commission + tons::TON_SIMPLE_OFFER_RESERVE;
                throw_unless(exc::OUT_OF_GAS, my_balance > balance_to_reserve + tons::MIN_RESERVE);
                raw_reserve(balance_to_reserve, 0);
                send_message_with_comment(from_address, 0, "Counterproposal sent", mode::CARRY_REMAINING_BALANCE);
            }
            else {
                throw(exc::UNSUPPORTED_OP);
            }
            
            save_data();
            return ();
        }
        catch (_, n) {
            if (storage::state == state::ACTIVE) {
                raw_reserve(storage::price + storage::commission + tons::TON_SIMPLE_OFFER_RESERVE, 0);
            }
            transfer_nft(query_id, sender_address, from_address, from_address, 0, mode::CARRY_REMAINING_BALANCE, 1,
                         payload_with_comment("Error, code ").store_number10(n).end_cell());

            commit();
            throw(n);
            
            return ();
        }
    }

    throw_unless(exc::DEAL_NOT_ACTIVE, storage::state == state::ACTIVE);
    
    ;; Counterpropose after nft transfer
    if (op == op::COUNTERPROPOSE) {
        slice seller_address = storage::seller_address_cell.begin_parse();
        throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, seller_address));
        throw_unless(exc::DEAL_NOT_ACTIVE, (storage::valid_until > now_time) & (storage::seller_price > 0));

        storage::seller_price = in_msg_body~load_coins();
        if (storage::seller_price == storage::price) {
            accept_offer(seller_address, msg_value, query_id);
        }
        else {
            throw_unless(exc::INCORRECT_PRICE, storage::seller_price - storage::price >= tons::MIN_PRICE_CHANGE);
            int notify_buyer = in_msg_body~load_int(1);
            if (notify_buyer) {
                send_message_with_comment(storage::buyer_address, tons::OFFER_NOTIFICATION, "You have received a counterproposal for your offer on webdom.market", mode::PAY_FEES_SEPARATELY);
                my_balance -= tons::OFFER_NOTIFICATION;
            }
            send_message_with_comment(MARKETPLACE_ADDRESS, tons::COUNTERPROPOSE_PRICE, msg::MARKETPLACE_COMMISSION_MESSAGE, mode::SIMPLE);     ;; marketplace commission 

            int balance_to_reserve = storage::price + storage::commission + tons::TON_SIMPLE_OFFER_RESERVE;
            if (my_balance > balance_to_reserve + tons::COUNTERPROPOSE_PRICE + tons::MIN_EXCESS) {
                raw_reserve(balance_to_reserve, 0);
                send_message_with_comment(seller_address, 0, "Counterproposal sent", mode::CARRY_REMAINING_BALANCE);
            }
        }
        save_data();
        return ();
    }

    ;; Change price
    if (op == op::CHANGE_PRICE) {
        throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::buyer_address));
        int new_price = in_msg_body~load_coins();
        throw_unless(exc::INCORRECT_PRICE, new_price - storage::price >= tons::MIN_PRICE_CHANGE);

        int new_valid_until = in_msg_body~load_uint(32);
        int notify_seller = in_msg_body~load_uint(1); 

        int new_commission = muldiv(new_price, storage::commission, storage::price);
        
        msg_value -= (tons::CHANGE_PRICE + notify_seller * tons::OFFER_NOTIFICATION);
        int max_new_price = storage::price + msg_value + storage::commission - new_commission;
        
        throw_unless(exc::OUT_OF_GAS, new_price <= max_new_price);
        throw_unless(exc::INCORRECT_VALID_UNTIL, new_valid_until >= max(now_time + 300, storage::valid_until));  ;; check that the new valid until time is in the future
        
        storage::price = new_price;
        storage::valid_until = new_valid_until;
        storage::commission = new_commission;
        storage::created_at = now_time;

        if (new_price == storage::seller_price) {  ;; accept counterproposal
            accept_offer(storage::seller_address_cell.begin_parse(), 0, query_id);
        }
        else {  ;; change price
            if (notify_seller & (~ null?(storage::seller_address_cell))) {
                ;; Notify the domain owner that he has a new offer
                slice tmp = storage::seller_address_cell.begin_parse();
                slice seller_address = tmp~load_msg_addr();
                cell payload = payload_with_comment("New offer on webdom.market! ").store_str_float(new_price, ONE_TON).store_slice(" TON for ").store_ref(storage::domain_name).end_cell();
                send_cell_message(seller_address, tons::OFFER_NOTIFICATION, payload, mode::PAY_FEES_SEPARATELY);
            }
            if (storage::seller_price != 0) { 
                send_message_with_comment(MARKETPLACE_ADDRESS, tons::COUNTERPROPOSE_PRICE, msg::MARKETPLACE_COMMISSION_MESSAGE, mode::SIMPLE);     ;; marketplace commission 
            }

            ;; Notify the buyer that the price has changed successfully

            raw_reserve(new_price + new_commission + tons::TON_SIMPLE_OFFER_RESERVE, 0);
            cell payload = payload_with_comment("Price changed to ").store_str_float(storage::price, ONE_TON).end_cell();
            send_cell_message(storage::buyer_address, 0, payload, mode::CARRY_REMAINING_BALANCE);
        }
        save_data();
        return ();
    }

    ;; Change valid until
    if (op == op::CHANGE_VALID_UNTIL) {
        throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::buyer_address));
        int new_valid_until = in_msg_body~load_uint(32);
        throw_unless(exc::INCORRECT_VALID_UNTIL, new_valid_until >= max(now_time + 300, storage::valid_until));  ;; check that the new valid until time is in the future
        storage::valid_until = new_valid_until;
        save_data();
        
        raw_reserve(storage::price + storage::commission + tons::TON_SIMPLE_OFFER_RESERVE, mode::IGNORE_ERRORS);
        send_message_with_comment(storage::buyer_address, 0, "Valid until time updated", mode::CARRY_REMAINING_BALANCE);
        
        return ();
    }

    ;; Cancel offer
    if (op == op::CANCEL_DEAL) {
        slice seller_address = "";
        ifnot (null?(storage::seller_address_cell)) {
            slice tmp = storage::seller_address_cell.begin_parse();
            seller_address = tmp~load_msg_addr();
        }
        slice cancellation_comment = "Your offer on webdom.market was cancelled";
        if (equal_slices(sender_address, storage::buyer_address)) {
            ;; wait for at least 10 minutes after the offer creation or until the offer expiration
            throw_unless(exc::CANT_CANCEL_DEAL, (storage::created_at + 600 < now_time) | (storage::valid_until < now_time) | (storage::seller_price != 0));
            msg_value = 0;
        }
        elseif (equal_slices(sender_address, seller_address)) {
            if (in_msg_body.slice_bits()) {
                cancellation_comment = in_msg_body;
            }
            storage::cancelled_by_seller = true;
        }
        else {
            throw(exc::INCORRECT_SENDER);
        }
        cancel_offer(msg_value, cancellation_comment, query_id);
        return ();
    }
    
    throw(exc::UNSUPPORTED_OP);
}


() recv_external(slice in_msg_body) impure {
    load_data();

    throw_if(exc::DEAL_NOT_ACTIVE, storage::state != state::ACTIVE);
    
    int op_code = in_msg_body~load_uint(32);
    throw_if(exc::UNSUPPORTED_OP, op_code != op::CANCEL_DEAL);
    int query_id = in_msg_body~load_uint(64);
    if (now() >= storage::valid_until) {
        accept_message();        
        cancel_offer(0, "Offer expired", query_id);
        return ();
    }
    else {
        throw_if(exc::INVALID_SIGNATURE, null?(storage::public_key_cell));
        slice pks = storage::public_key_cell.begin_parse();
        int public_key = pks~load_uint(256);
        
        slice signature = in_msg_body~load_bits(512);
        throw_unless(exc::INVALID_SIGNATURE, check_signature(slice_hash(in_msg_body), signature, public_key));
        cell msg_to_send = in_msg_body~load_ref();
        throw_unless(exc::INVALID_SIGNATURE, equal_slices(in_msg_body, my_address()));

        accept_message();
        cancel_offer(0, msg_to_send.begin_parse().skip_bits(32), query_id);
       
        return ();
    }
}


;; Get methods

(slice, cell, int, int, int, int, int, int, int, int, slice, cell, int, int, slice, int) get_storage_data() method_id {
    load_data();
     
    cell domains_dict = new_dict();
    domains_dict~dict_set(267, storage::domain_address, BIT_TRUE_SLICE());
    slice seller_address = cell_null?(storage::seller_address_cell) ? TWO_ZEROS_SLICE() : storage::seller_address_cell.begin_parse();

    return (
        seller_address,
        domains_dict, 
        1,
        storage::state == state::ACCEPTED ? 1 : 0,
        storage::state,
        storage::price, 
        muldiv(storage::commission, COMMISSION_DIVIDER, storage::price),
        storage::created_at,
        0,
        storage::valid_until, 
        storage::buyer_address, 
        
        storage::domain_name,
        storage::cancelled_by_seller,
        storage::seller_price,

        BURN_ADDRESS, 
        cell_hash(my_code()));
}

#include "legacy_get_methods.fc";