#include "../global_imports/all_imports.fc";
#include "constants.fc";


global slice storage::owner_address;
global int   storage::merkle_root;
global cell  storage::sold_nfts_dict;
global cell  storage::jetton_balances_dict;
global cell  storage::public_key_ref;
global int   storage::commission_factor;

global int   storage::web3_commission_factor;
global slice storage::web3_wallet_address;  ;; to consider lower fee in web3 tokens


() save_data() impure inline {
    set_data(
        begin_cell()
            .store_slice(storage::owner_address)
            .store_uint(storage::merkle_root, 256)
            .store_ref(storage::public_key_ref)
            .store_dict(storage::sold_nfts_dict)
            .store_dict(storage::jetton_balances_dict)
            .store_uint(storage::commission_factor, 16)
            .store_uint(storage::web3_commission_factor, 16)
            .store_slice(storage::web3_wallet_address)
        .end_cell()
    );
}

() load_data() impure inline {
    slice ds = get_data().begin_parse();  ;; Bits = 267 + 256 + 1 + 1 + 16 + 267 + 16 = 824, Refs = 3
    storage::owner_address          = ds~load_msg_addr();
    storage::merkle_root            = ds~load_uint(256);
    storage::public_key_ref         = ds~load_ref();
    storage::sold_nfts_dict         = ds~load_dict();
    storage::jetton_balances_dict   = ds~load_dict();
    storage::commission_factor      = ds~load_uint(16);
    storage::web3_commission_factor = ds~load_uint(16);
    storage::web3_wallet_address    = ds~load_msg_addr();

    ds.end_parse();
}


(int) get_jetton_balance(slice jetton_wallet_address) inline {
    (slice balance_info, int found?) = storage::jetton_balances_dict.dict_get?(267, jetton_wallet_address);
    return (found? ? balance_info~load_coins() : 0);
}

() set_jetton_balance(slice jetton_wallet_address, int balance) impure inline {
    storage::jetton_balances_dict~dict_set_builder(267, jetton_wallet_address, begin_cell().store_coins(balance));
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    if (flags & 1) {  ;; bounced messages
        return ();
    }
    force_same_workchain(sender_address);

    load_data();

    int op = 0;
    int query_id = 0;
    if (in_msg_body.slice_bits()) {
        op = in_msg_body~load_uint(32);
    }
    if (op != 0) {
        query_id = in_msg_body~load_uint(64);
    }
    elseif (equal_slices(in_msg_body, msg::CANCEL_MESSAGE)) {
        op = op::CANCEL_DEAL;
    }
    elseif (equal_slices(in_msg_body, msg::FILL_UP_BALANCE_MESSAGE) | equal_slices(sender_address, storage::owner_address)) {
        op = op::FILL_UP_BALANCE;
    }

    if (op == op::EXCESSES) {
        return ();
    }

    if (op == op::FILL_UP_BALANCE) {
        ;; deploy
        if (equal_slices(sender_address, MARKETPLACE_ADDRESS)) {
            if (storage::merkle_root) {  ;; prevent accepting multiple deploy requests
                send_message_with_comment(storage::owner_address, 0, "Offer has already been created", mode::CARRY_REMAINING_GAS);
                commit();
                throw(exc::ALREADY_DEPLOYED);
                return ();
            }

            storage::merkle_root            = in_msg_body~load_uint(256);
            storage::commission_factor      = in_msg_body~load_uint(16);
            storage::web3_commission_factor = in_msg_body~load_uint(16);
            storage::web3_wallet_address    = in_msg_body~load_msg_addr();

            save_data();
            return ();
        }
        ;; fill up balance
        return ();
    }

    if (op == op::OWNERSHIP_ASSIGNED) {
        slice from_address = in_msg_body~load_msg_addr();
        
        try {
            throw_unless(exc::DEAL_NOT_ACTIVE, storage::merkle_root);

            (_, int already_sold?) = storage::sold_nfts_dict.dict_get?(267, sender_address);
            throw_if(exc::NFT_ALREADY_SOLD, already_sold?);

            cell proof_cell = in_msg_body~load_maybe_ref();
            (slice proof_cell_slice, int exotic?) = proof_cell.begin_parse_exotic();
            throw_unless(exc::INCORRECT_EXOTIC_CELL, exotic? & (proof_cell_slice~load_uint(8) == 3));
            throw_unless(exc::INCORRECT_PROOF, storage::merkle_root == proof_cell_slice~load_uint(256));

            cell dict = proof_cell_slice~load_ref();
            (slice price_info, int found?) = dict.dict_get?(267, sender_address);
            throw_unless(exc::NFT_NOT_FOUND, found?);

            int price = price_info~load_coins();
            int valid_until = price_info~load_uint(32);
            throw_unless(exc::DEAL_NOT_ACTIVE, valid_until >= now());

            int commission = muldiv(price, storage::commission_factor, COMMISSION_DIVIDER);
            int remaining_balance = 0;
            int one_jetton = 1000000000;
            slice symbol = "TON";

            if (price_info~load_int(1) == 0) {
                throw_unless(exc::OUT_OF_GAS, (my_balance > price + tons::NFT_TRANSFER + tons::MIN_RESERVE));

                if (commission > tons::MIN_EXCESS) {
                    send_message_with_comment(MARKETPLACE_ADDRESS, commission, "Marketplace commission", mode::SIMPLE);
                }
                send_message_with_comment(from_address, price - commission, "NFT sold on webdom.market", mode::PAY_FEES_SEPARATELY);

                remaining_balance = my_balance - price - tons::NFT_TRANSFER - tons::MIN_RESERVE;
            }
            else {
                slice jetton_wallet_address = price_info~load_msg_addr();
                one_jetton                  = price_info~load_coins();
                symbol                      = price_info;

                int jetton_balance = get_jetton_balance(jetton_wallet_address);
                throw_unless(exc::NOT_ENOUGH_JETTONS, (jetton_balance >= price));
                throw_unless(exc::OUT_OF_GAS, (my_balance > tons::NFT_TRANSFER + tons::JETTON_TRANSFER + tons::MIN_RESERVE));
                
                if (equal_slices(jetton_wallet_address, storage::web3_wallet_address)) {
                    commission = muldiv(price, storage::web3_commission_factor, COMMISSION_DIVIDER);
                }
            
                if (commission > 0) {
                    send_jettons(query_id, commission, MARKETPLACE_ADDRESS, my_address(), jetton_wallet_address, tons::JETTON_TRANSFER, 
                                mode::SIMPLE, 1, MARKETPLACE_COMMISSION_NOTIFICATION());
                }
                send_jettons(query_id, price - commission, from_address, my_address(), jetton_wallet_address, tons::JETTON_TRANSFER, 
                             mode::SIMPLE, 1, NFT_SOLD_NOTIFICATION());
                
                remaining_balance = jetton_balance - price;
                set_jetton_balance(jetton_wallet_address, remaining_balance);
            }

            transfer_nft(query_id, sender_address, storage::owner_address, from_address, tons::NFT_TRANSFER, mode::SIMPLE, 1,
                                payload_with_comment("webdom order executed. Remaining balance: ").store_str_jettons(remaining_balance, one_jetton, symbol).end_cell());
            storage::sold_nfts_dict~dict_set_builder(267, sender_address, begin_cell().store_uint(now(), 32));
            
            save_data();
            return ();
        }
        catch (_, n) {
            transfer_nft(query_id, sender_address, from_address, from_address, 0, mode::CARRY_REMAINING_GAS, 1,
                         payload_with_comment("Error, code ").store_number10(n).end_cell());

            commit();
            throw(n);

            return ();
        }
    }

    if (op == op::TRANSFER_NOTIFICATION) {
        int   transferred_jettons = in_msg_body~load_coins();
        slice from_address        = in_msg_body~load_msg_addr();
        slice payload             = in_msg_body~load_int(1) ? in_msg_body~load_ref().begin_parse() : in_msg_body;
        
        int coins_to_reserve = 0;
        if (payload~load_int(1)) {
            coins_to_reserve = payload~load_coins();
        }
        raw_reserve(coins_to_reserve, 4);  ;; if user wants to fill up TON balance

        int prev_jetton_balance = get_jetton_balance(sender_address);
        set_jetton_balance(sender_address, prev_jetton_balance + transferred_jettons);
        if (msg_value - coins_to_reserve > tons::MIN_EXCESS) {
            send_message_with_comment(from_address, 0, "Jetton balance of the multi-offer was filled up", mode::CARRY_REMAINING_BALANCE);
        }

        save_data();
        return ();
    }

    throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::owner_address));
    
    if (op == op::SET_NEW_DATA) {
        ;; Мы используем здесь подписи, чтобы быть уверенным, что нужный словарь будет сохранен на бэкенде
        slice public_key_slice = storage::public_key_ref.begin_parse();
        int public_key         = public_key_slice~load_uint(256);

        slice update_info = in_msg_body~load_ref().begin_parse();
        slice signature = update_info~load_ref().begin_parse();

        throw_unless(exc::INVALID_SIGNATURE, check_signature(slice_hash(update_info), signature, public_key));
        int sign_time = update_info~load_uint(32);
        slice address = update_info~load_msg_addr();
        throw_unless(exc::INVALID_SIGNATURE, equal_slices(address, my_address()));
        throw_unless(exc::INVALID_SIGNATURE, sign_time + 600 >= now());

        storage::merkle_root = update_info~load_uint(256);
        
        ;; Удаляем информацию только о тех NFT, которые были гарантированно убраны из словаря
        (slice nft_address, slice sold_time_slice, int found?) = storage::sold_nfts_dict.dict_get_min?(267);
        while (found?) {
            int sold_time = sold_time_slice~load_uint(32);
            if (sold_time < sign_time) {
                storage::sold_nfts_dict~dict_delete?(267, nft_address);
            }
            (nft_address, sold_time_slice, found?) = storage::sold_nfts_dict.dict_get_next?(267, nft_address);
        }
        send_message_with_comment(storage::owner_address, 0, "Multiple offer successfully updated", mode::CARRY_REMAINING_GAS);

        save_data();
        return ();
    }

    if (op == op::WITHDRAW_TON) {
        int amount = in_msg_body~load_coins();
        raw_reserve(((amount > my_balance - msg_value) | (amount == 0)) ? tons::MIN_RESERVE : (my_balance - amount - msg_value), 0);
        send_message_with_comment(sender_address, amount, "TON withdrawal", mode::CARRY_REMAINING_BALANCE);
        return ();
    }

    if (op == op::WITHDRAW_JETTON) {
        throw_unless(exc::OUT_OF_GAS, msg_value > tons::JETTON_TRANSFER);

        slice jetton_wallet_address = in_msg_body~load_msg_addr();
        int   amount                = in_msg_body~load_coins();

        send_jettons(query_id, amount, sender_address, sender_address, jetton_wallet_address, tons::JETTON_TRANSFER, 
                     mode::CARRY_REMAINING_GAS, 1, payload_with_comment("Jetton withdrawal").end_cell());
        
        int jetton_balance = get_jetton_balance(jetton_wallet_address);
        set_jetton_balance(jetton_wallet_address, max(jetton_balance - amount, 0));

        save_data();
        return ();
    }

    if (op == op::CANCEL_DEAL) {
        (slice jetton_wallet_address, slice jetton_balance_slice, int found?) = storage::jetton_balances_dict.dict_get_min?(267);
        while (found?) {
            int jetton_balance = jetton_balance_slice~load_coins();
            if (jetton_balance > 0) {
                send_jettons(query_id, jetton_balance, sender_address, sender_address, jetton_wallet_address, tons::JETTON_TRANSFER, 
                                mode::SIMPLE, 1, payload_with_comment("Jetton withdrawal").end_cell());
            }
            (jetton_wallet_address, jetton_balance_slice, found?) = storage::jetton_balances_dict.dict_get_next?(267, jetton_wallet_address);
        }
        send_message_with_comment(storage::owner_address, 0, "Multiple offer was cancelled", mode::CARRY_REMAINING_BALANCE);
        
        storage::merkle_root = 0;
        storage::jetton_balances_dict = null();
        storage::sold_nfts_dict = null();
        save_data();

        return ();
    }

    throw(exc::UNSUPPORTED_OP);
    return ();
}


(slice, int, int, int, int, cell, cell, slice) get_storage_data() inline_ref method_id {     
    load_data();
    slice public_key_slice = storage::public_key_ref.begin_parse();
    int   public_key       = public_key_slice~load_uint(256);
    return (
        storage::owner_address,
        storage::merkle_root,
        public_key,
        storage::commission_factor,
        storage::web3_commission_factor,
        storage::sold_nfts_dict,
        storage::jetton_balances_dict,
        storage::web3_wallet_address
    );
}

;; Just for webdom backend 
(slice, int, int, int, cell, cell, slice) get_multiple_offer_data() method_id {
    load_data();
    return (
        storage::owner_address,
        storage::merkle_root,
        storage::commission_factor,
        storage::web3_commission_factor,
        storage::sold_nfts_dict,
        storage::jetton_balances_dict,
        MARKETPLACE_ADDRESS
    );
}