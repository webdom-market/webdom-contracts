#include "../global_imports/all_imports.fc";
#include "constants.fc";


global int   storage::state;
global int   storage::price;
global int   storage::commission;
global int   storage::valid_until;
global slice storage::seller_address;
global slice storage::jetton_wallet_address;
global int   storage::cancelled_by_seller;
global int   storage::seller_price;

global int   storage::created_at;
global slice storage::domain_address;
global slice storage::buyer_address;
global slice storage::jetton_minter_address;
global cell  storage::domain_name;
global cell  storage::public_key_cell;

global slice const_storage_slice;


() load_data() impure {
    slice ds = get_data().begin_parse();  ;; Bits = 2 + 124 + 124 + 32 + 267 + 267 + 1 + 124 = 817, Refs = 1
    storage::state                 = ds~load_uint(2);
    storage::price                 = ds~load_coins();
    storage::commission            = ds~load_coins();
    storage::valid_until           = ds~load_uint(32);
    storage::seller_address        = ds~load_msg_addr();
    storage::jetton_wallet_address = ds~load_msg_addr();
    storage::cancelled_by_seller   = ds~load_int(1);
    storage::seller_price          = ds~load_coins();

    const_storage_slice = ds; 

    storage::created_at            = ds~load_uint(32);
    
    slice ds2 = ds~load_ref().begin_parse();
    ds.end_parse();

    storage::domain_address        = ds2~load_msg_addr();
    storage::buyer_address         = ds2~load_msg_addr();
    storage::jetton_minter_address = ds2~load_msg_addr();
    storage::domain_name           = ds2~load_ref();
    storage::public_key_cell       = ds2~load_maybe_ref();

    ds2.end_parse();
    return ();
}


#include "../global_imports/admin_functions.fc";  


() save_data() impure inline {
    set_data(
        begin_cell()
            .store_uint(storage::state, 2)
            .store_coins(storage::price)
            .store_coins(storage::commission)
            .store_uint(storage::valid_until, 32)
            .store_slice(storage::seller_address)
            .store_slice(storage::jetton_wallet_address)
            .store_int(storage::cancelled_by_seller, 1)
            .store_coins(storage::seller_price)
            .store_slice(const_storage_slice)
        .end_cell()
    );
}


() accept_offer(int seller_msg_value, int query_id) impure {
    if (storage::commission) {
        send_jettons(query_id, storage::commission, MARKETPLACE_ADDRESS, storage::buyer_address, storage::jetton_wallet_address, 
                        tons::JETTON_TRANSFER + tons::NOTIFY_MARKETPLACE, mode::SIMPLE, tons::NOTIFY_MARKETPLACE, MARKETPLACE_COMMISSION_NOTIFICATION());  ;; marketplace commission 
    }
    send_jettons(query_id, storage::price, storage::seller_address, storage::buyer_address, 
                    storage::jetton_wallet_address, tons::JETTON_TRANSFER + seller_msg_value, mode::SIMPLE, seller_msg_value, OFFER_ACCEPTED_NOTIFICATION());  ;; seller payout
    
    transfer_nft(query_id, storage::domain_address, storage::buyer_address, storage::buyer_address, 0, mode::CARRY_REMAINING_BALANCE, tons::PURCHASE_NOTIFICATION, BUYER_NOTIFICATION());  ;; domain transfer
    
    storage::state = state::ACCEPTED;
    storage::valid_until = now() - 1;
}


() cancel_offer(int seller_msg_value, slice cancellation_comment, int query_id) impure inline_ref {
    if (storage::seller_price) {
        transfer_nft(query_id, storage::domain_address, storage::seller_address, storage::buyer_address, tons::NFT_TRANSFER, mode::SIMPLE, 1, COUNTERPROPOSAL_REJECTED_NOTIFICATION());  
    }
    elseif (seller_msg_value > 0) {
        send_excess(storage::seller_address, query_id, seller_msg_value + tons::DECLINE_REWARD, mode::PAY_FEES_SEPARATELY);
    }

    storage::state = state::CANCELLED;
    storage::valid_until = min(storage::valid_until, now());
    save_data();
    
    send_jettons(query_id, storage::price + storage::commission, storage::buyer_address, storage::buyer_address, storage::jetton_wallet_address,
                    0, mode::CARRY_REMAINING_BALANCE, 1, payload_with_comment(cancellation_comment).end_cell());
    return ();
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    if (flags & 1) {  ;; bounced messages
        return ();
    }
    force_same_workchain(sender_address);

    load_data();

    int op = 0;
    int query_id = 0;
    if (in_msg_body.slice_bits()) {
        op = in_msg_body~load_uint(32);
    }
    if (op != 0) {
        query_id = in_msg_body~load_uint(64);
    }
    elseif (equal_slices(in_msg_body, msg::CANCEL_MESSAGE)) {
        op = op::CANCEL_DEAL;
    }

    if ((op == op::FILL_UP_BALANCE) & (equal_slices(sender_address, MARKETPLACE_ADDRESS))) {
        if(storage::state) {  ;; prevent accepting multiple deploy requests
            send_message_with_comment(storage::buyer_address, 0, "Offer has already been created", mode::CARRY_REMAINING_GAS);
            return ();
        }
        get_jetton_wallet_address(storage::jetton_minter_address, mode::CARRY_REMAINING_GAS);
        storage::state = state::ACTIVE;
        save_data();
        return ();
    }
    if (op == op::TAKE_WALLET_ADDRESS) {
        throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::jetton_minter_address));
        if (my_balance > tons::JETTON_SIMPLE_OFFER_RESERVE + tons::MIN_EXCESS) {
            raw_reserve(tons::JETTON_SIMPLE_OFFER_RESERVE, 0);
            send_message_with_comment(storage::buyer_address, 0, "offer deployed", mode::CARRY_REMAINING_BALANCE);
        }
        storage::jetton_wallet_address = in_msg_body~load_msg_addr();
        save_data();
        return ();
    }

    ;; Fill up balance
    if (op == op::FILL_UP_BALANCE) {
        return ();
    }

    handle_admin_message(op, sender_address, in_msg_body, msg_value, storage::state != state::ACTIVE, storage::state != state::ACTIVE);

    int now_time = now();

    ;; Exchage domain for jetton
    if (op == op::OWNERSHIP_ASSIGNED) {
        slice from_address = in_msg_body~load_msg_addr();
        
        slice payload = in_msg_body~load_int(1) ? in_msg_body~load_ref().begin_parse() : in_msg_body;
        int inner_op = payload.slice_bits() ? payload~load_uint(32) : 0;

        try {
            throw_unless(exc::DEAL_NOT_ACTIVE, (storage::valid_until > now_time) & (storage::state == state::ACTIVE) & (~ equal_slices(storage::jetton_wallet_address, TWO_ZEROS_SLICE())));
            throw_unless(exc::INCORRECT_DOMAIN, equal_slices(sender_address, storage::domain_address));
            storage::seller_address = from_address;
            if (inner_op == 0) {
                accept_offer(msg_value, query_id);
            }
            elseif (inner_op == op::COUNTERPROPOSE) {
                storage::seller_price = payload~load_coins();
                throw_unless(exc::INCORRECT_PRICE, storage::seller_price - storage::price >= 100000);  ;; delta must be at least 0.1 USDT or 10 WEB3
                
                int notify_buyer = payload~load_int(1);
                if (notify_buyer) {
                    send_message_with_comment(storage::buyer_address, tons::OFFER_NOTIFICATION, "You have received a counterproposal for your offer on webdom.market", mode::PAY_FEES_SEPARATELY);
                    my_balance -= tons::OFFER_NOTIFICATION;
                }
                ;; send_message_with_comment(MARKETPLACE_ADDRESS, tons::COUNTERPROPOSE_PRICE, msg::MARKETPLACE_COMMISSION_MESSAGE, mode::SIMPLE);     ;; marketplace commission 
                ;; my_balance -= tons::COUNTERPROPOSE_PRICE;
                throw_unless(exc::OUT_OF_GAS, my_balance > tons::JETTON_SIMPLE_OFFER_RESERVE + tons::MIN_RESERVE);
                raw_reserve(tons::JETTON_SIMPLE_OFFER_RESERVE, 0);
                send_message_with_comment(from_address, 0, "Counterproposal sent", mode::CARRY_REMAINING_BALANCE);
            }
            else {
                throw(exc::UNSUPPORTED_OP);
            }

            save_data();
            return ();
        }
        catch (_, n) {
            if (storage::state == state::ACTIVE) {
                raw_reserve(tons::JETTON_SIMPLE_OFFER_RESERVE, 0);
            }
            transfer_nft(query_id, sender_address, from_address, from_address, 0, mode::CARRY_REMAINING_BALANCE, 1,
                         payload_with_comment("Error, code ").store_number10(n).end_cell());

            commit();
            throw(n);
            
            return ();
        }
    }

    if (op == op::TRANSFER_NOTIFICATION) {
        int   transferred_jettons = in_msg_body~load_coins();
        slice from_address        = in_msg_body~load_msg_addr();

        try {
            slice payload = in_msg_body~load_int(1) ? in_msg_body~load_ref().begin_parse() : in_msg_body;
            int inner_op = payload~load_uint(32);
            throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::jetton_wallet_address) & equal_slices(from_address, storage::buyer_address));
            throw_unless(exc::DEAL_NOT_ACTIVE, storage::state == state::ACTIVE);

            if (inner_op == op::CHANGE_PRICE) {
                int new_valid_until = payload~load_uint(32);
                int notify_seller   = payload~load_uint(1); 
                
                int price_delta = muldiv(transferred_jettons, storage::price, storage::commission + storage::price);
                storage::price = storage::price + price_delta;
                storage::commission = storage::commission + transferred_jettons - price_delta;
                
                if (storage::price == storage::seller_price) {
                    accept_offer(0, query_id);
                }
                else {
                    if (storage::seller_price != 0) {
                        send_message_with_comment(MARKETPLACE_ADDRESS, tons::COUNTERPROPOSE_PRICE, msg::MARKETPLACE_COMMISSION_MESSAGE, mode::SIMPLE);     ;; marketplace commission 
                        msg_value -= tons::COUNTERPROPOSE_PRICE;
                    }
                    throw_unless(exc::OUT_OF_GAS, msg_value >= tons::OFFER_NOTIFICATION * notify_seller + tons::MIN_EXCESS);
                    throw_unless(exc::INCORRECT_VALID_UNTIL, new_valid_until >= max(now_time + 300, storage::valid_until));  ;; check that the new valid until time is in the future
                    storage::valid_until = new_valid_until;

                    int one_jetton = ONE_TON;
                    slice jetton_name = " JETTON";
                    if (equal_slices(storage::jetton_minter_address, USDT_ADDRESS)) {
                        one_jetton = 1000000;
                        jetton_name = " USDT";
                    }
                    elseif (equal_slices(storage::jetton_minter_address, WEB3_ADDRESS)) {
                        one_jetton = 1000;
                        jetton_name = " WEB3";
                    }

                    if (notify_seller & (~ equal_slices(storage::seller_address, TWO_ZEROS_SLICE()))) {
                        ;; Notify the domain owner that he has a new offer
                        cell payload = payload_with_comment("New offer on webdom.market! ").store_str_float(storage::price, one_jetton).store_slice(jetton_name).store_slice(" for ").store_ref(storage::domain_name).end_cell();
                        send_cell_message(storage::seller_address, tons::OFFER_NOTIFICATION, payload, mode::PAY_FEES_SEPARATELY);
                    }
                    
                    ;; Notify the buyer that the price has changed successfully
                    raw_reserve(tons::JETTON_SIMPLE_OFFER_RESERVE, 0);
                    builder payload = payload_with_comment("Price changed to ").store_str_float(storage::price, one_jetton);
                    send_builder_message(storage::buyer_address, 0, payload, mode::CARRY_REMAINING_BALANCE);
                }

                save_data();
                return ();
            }

            throw(exc::UNSUPPORTED_OP);
        }
        catch (_, n) { ;; if something went wrong contract tries to return jettons back with corresponding error code as a comment
            if (storage::state == state::ACTIVE) {
                raw_reserve(tons::JETTON_SIMPLE_OFFER_RESERVE, 0);
            }
            send_jettons(query_id, transferred_jettons, from_address, from_address, sender_address, 0, mode::CARRY_REMAINING_BALANCE,
                           1, payload_with_comment("Error. Code ").store_number10(n).end_cell());  

            commit();
            throw(n);
            
            return ();
        }
    }

    ;; Counterpropose after nft transfer
    if (op == op::COUNTERPROPOSE) {
        throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::seller_address));
        throw_unless(exc::DEAL_NOT_ACTIVE, (storage::valid_until > now_time) & (storage::state == state::ACTIVE) & (storage::seller_price > 0));

        storage::seller_price = in_msg_body~load_coins();
        if (storage::seller_price == storage::price) {
            accept_offer(msg_value, query_id);
        }
        else {
            throw_unless(exc::INCORRECT_PRICE, storage::seller_price - storage::price >= 100000);  ;; delta must be at least 0.1 USDT or 10 WEB3
            int notify_buyer = in_msg_body~load_int(1);
            if (notify_buyer) {
                send_message_with_comment(storage::buyer_address, tons::OFFER_NOTIFICATION, "You have received a counterproposal for your offer on webdom.market", mode::PAY_FEES_SEPARATELY);
                my_balance -= tons::OFFER_NOTIFICATION;
            }
            send_message_with_comment(MARKETPLACE_ADDRESS, tons::COUNTERPROPOSE_PRICE, msg::MARKETPLACE_COMMISSION_MESSAGE, mode::SIMPLE);     ;; marketplace commission 
            
            if (my_balance > tons::JETTON_SIMPLE_OFFER_RESERVE + tons::COUNTERPROPOSE_PRICE + tons::MIN_EXCESS) {
                raw_reserve(tons::JETTON_SIMPLE_OFFER_RESERVE, 0);
                send_message_with_comment(storage::seller_address, 0, "Counterproposal sent", mode::CARRY_REMAINING_BALANCE);
            }
        }
        save_data();
        return ();
    }

    ;; Cancel offer
    if (op == op::CANCEL_DEAL) {
        slice seller_address = "";
        slice cancellation_comment = "Your offer on webdom.market was cancelled";
        if (equal_slices(sender_address, storage::buyer_address)) {
            ;; wait for at least 10 minutes after the offer creation or until the offer expiration
            throw_unless(exc::CANT_CANCEL_DEAL, (storage::created_at + 600 < now_time) | (storage::valid_until < now_time) | (storage::seller_price != 0));
            msg_value = 0;
        }
        elseif (equal_slices(sender_address, storage::seller_address)) {
            if (in_msg_body.slice_bits()) {
                cancellation_comment = in_msg_body;
            }
            storage::cancelled_by_seller = true;
        }
        else {
            throw(exc::INCORRECT_SENDER);
        }
        cancel_offer(msg_value, cancellation_comment, query_id);
        return ();
    }

    ;; Change valid until
    if (op == op::CHANGE_VALID_UNTIL) {
        throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::buyer_address));
        int new_valid_until = in_msg_body~load_uint(32);
        throw_unless(exc::INCORRECT_VALID_UNTIL, new_valid_until >= max(now_time + 300, storage::valid_until));  ;; check that the new valid until time is in the future
        storage::valid_until = new_valid_until;
        save_data(); 
        
        raw_reserve(tons::JETTON_SIMPLE_OFFER_RESERVE, 0);
        send_message_with_comment(storage::buyer_address, 0, "Valid until time updated", mode::CARRY_REMAINING_BALANCE);
        
        return ();
    }
    
    throw(exc::UNSUPPORTED_OP);
}


() recv_external(slice in_msg_body) impure {
    load_data();

    throw_if(exc::DEAL_NOT_ACTIVE, storage::state != state::ACTIVE);

    int op_code = in_msg_body~load_uint(32);
    throw_if(exc::UNSUPPORTED_OP, op_code != op::CANCEL_DEAL);
    int query_id = in_msg_body~load_uint(64);
    if (now() >= storage::valid_until) {
        accept_message();
        cancel_offer(0, "Offer expired", query_id);
        return ();
    }
    else {
        throw_if(exc::INVALID_SIGNATURE, null?(storage::public_key_cell));
        slice pks = storage::public_key_cell.begin_parse();
        int public_key = pks~load_uint(256);

        slice signature = in_msg_body~load_bits(512);
        throw_unless(exc::INVALID_SIGNATURE, check_signature(slice_hash(in_msg_body), signature, public_key));
        cell msg_to_send = in_msg_body~load_ref();
        throw_unless(exc::INVALID_SIGNATURE, equal_slices(in_msg_body, my_address()));

        accept_message();
        cancel_offer(0, msg_to_send.begin_parse().skip_bits(32), query_id);
       
        save_data();
        return ();
    }
}


;; Get methods

(slice, cell, int, int, int, int, int, int, int, int, slice, cell, int, slice, int, slice, int) get_storage_data() method_id {
    load_data();
     
    cell domains_dict = new_dict();
    domains_dict~dict_set(267, storage::domain_address, BIT_TRUE_SLICE());
    
    return (
        storage::seller_address,
        domains_dict, 
        1,
        storage::state == state::ACCEPTED ? 1 : 0,
        storage::state,
        storage::price, 
        muldiv(storage::commission, COMMISSION_DIVIDER, storage::price),
        storage::created_at,
        0,
        storage::valid_until, 
        storage::buyer_address, 

        storage::domain_name,
        storage::cancelled_by_seller,
        storage::jetton_wallet_address,
        storage::seller_price,

        storage::jetton_minter_address, 
        cell_hash(my_code()));
}

#include "legacy_get_methods.fc";