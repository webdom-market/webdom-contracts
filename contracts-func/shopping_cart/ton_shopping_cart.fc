#include "../global_imports/all_imports.fc";
#include "constants.fc";


(slice, int, cell, int, int) load_data() impure {
    slice ds = get_data().begin_parse();
    var tmp = (
        ds~load_msg_addr(),  ;; owner_address (MsgAddress)
        ds~load_uint(1),     ;; state (uint1, 0 - uninit, 1 - active)
        ds~load_dict(),      ;; domains_dict (HashmapE: DomainAddress(MsgAddress) -> {Transferred?(Bool), SaleContractAddress(MsgAddress), Price(Coins), SwapInfo(Maybe ^Cell)})
        ds~load_coins(),     ;; commission (Coins)
        ds~load_uint(8)      ;; domains_left (uint8)
    );
    ds.end_parse();
    return tmp;
}


#include "../global_imports/admin_functions.fc";  


() save_data(slice storage::owner_address, int storage::state, cell storage::domains_dict, 
             int storage::commission, int storage::domains_left) impure inline {
    set_data(
        begin_cell()
            .store_slice(storage::owner_address)
            .store_uint(storage::state, 1)
            .store_dict(storage::domains_dict)
            .store_coins(storage::commission)
            .store_uint(storage::domains_left, 8)
        .end_cell()
    );
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    
    force_same_workchain(sender_address);
    
    (slice storage::owner_address, int storage::state, 
     cell storage::domains_dict, int storage::commission, int storage::domains_left) = load_data();
    if (flags & 1) {  ;; forward bounced messages to owner
        send_excess(storage::owner_address, 0, 0, mode::CARRY_REMAINING_GAS);
        return ();
    }

    int now_time = now();
    int op = 0;
    int query_id = 0;
    if (in_msg_body.slice_bits()) {
        op = in_msg_body~load_uint(32);
    }
    if (op != 0) {
        query_id = in_msg_body~load_uint(64);
    }
    handle_admin_message(op, sender_address, in_msg_body, msg_value, true, true);


    if (op == 0) {
        send_excess(storage::owner_address,query_id, 0, mode::CARRY_REMAINING_GAS);
        return ();
    }

    if (op == op::FILL_UP_BALANCE) {
        throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::owner_address));
        throw_if(exc::ALREADY_DEPLOYED, storage::state != state::UNINIT);

        (slice domain_address, slice domain_info, int found) = storage::domains_dict.dict_get_min?(267);
        storage::domains_left = 0;
        while (found) {
            domain_info~skip_bits(1);
            slice deal_address = domain_info~load_msg_addr();
            int   price = domain_info~load_coins();
            cell  swap_info = domain_info~load_maybe_ref();
            if (cell_null?(swap_info)) {
                storage::domains_left += 1;  ;; don't increase domains_left on swaps because those domains won't be transferred to this contract
                send_message_with_comment(deal_address, price + tons::PURCHASE_VIA_CART, "Purchase via webdom.market shopping cart", mode::SIMPLE);
            } 
            else {
                slice swap_info_slice = swap_info.begin_parse();
                int   swap_amount         = swap_info_slice~load_coins();
                slice dedust_pool_address = swap_info_slice~load_msg_addr();
                int   required_gas        = swap_info_slice~load_coins() + tons::PURCHASE_VIA_CART;
                swap_info_slice.end_parse();

                cell swap_message = ton_swap_buy_message(query_id, swap_amount, dedust_pool_address, price, deal_address, storage::owner_address);
                send_cell_message(TON_VAULT_ADDRESS, swap_amount + required_gas + tons::DEDUST_SWAP, swap_message, mode::SIMPLE);
            }
            (domain_address, domain_info, found) = storage::domains_dict.dict_get_next?(267, domain_address);
        }
        send_message_with_comment(MARKETPLACE_ADDRESS, storage::commission, msg::MARKETPLACE_COMMISSION_MESSAGE, mode::PAY_FEES_SEPARATELY);
        if (storage::domains_left == 0) {
            send_message_with_comment(storage::owner_address, 0, "Purchase completed", mode::CARRY_REMAINING_BALANCE);
        }
        save_data(storage::owner_address, state::ACTIVE, storage::domains_dict, storage::commission, storage::domains_left);
        return ();
    }
    
    if (op == op::OWNERSHIP_ASSIGNED) {
        slice from_address = in_msg_body~load_msg_addr();

        try {   
            (slice domain_info, int found) = storage::domains_dict.dict_get?(267, sender_address);
            throw_unless(exc::INCORRECT_SENDER, found);
            int transferred = domain_info~load_int(1);
            throw_if(exc::DOMAIN_ALREADY_TRANSFERRED, transferred);
            transfer_nft(query_id, sender_address, storage::owner_address, storage::owner_address, 0, mode::CARRY_REMAINING_GAS, 1, BUYER_NOTIFICATION());
            storage::domains_dict~dict_set_builder(267, sender_address, begin_cell().store_int(true, 1).store_slice(domain_info));
            storage::domains_left -= 1;
            if (storage::domains_left == 0) {
                send_message_with_comment(storage::owner_address, 0, "Purchase completed", mode::CARRY_REMAINING_BALANCE);
            }
            save_data(storage::owner_address, storage::state, storage::domains_dict, storage::commission, storage::domains_left);
            return ();
        }
        catch (_, n) {
            ;; Try to return the domain back to the sender in case of error
            raw_reserve(storage_fees(), 4);
            transfer_nft(query_id, sender_address, from_address, from_address, 0, mode::CARRY_REMAINING_BALANCE, 1,
                         payload_with_comment("Error, code ").store_number10(n).end_cell());

            commit();
            throw(n);
            
            return ();
        }
    }

    if (op == op::EXCESSES) {
        raw_reserve(storage_fees(), 4);
        send_excess(storage::owner_address, 0, 0, mode::CARRY_REMAINING_BALANCE);
        return ();
    }

    if (op == op::WITHDRAW_TON) {
        throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::owner_address));
        send_excess(storage::owner_address, query_id, 0, mode::CARRY_REMAINING_BALANCE);
        return ();
    }

    if (op == op::WITHDRAW_DOMAIN) {
        throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::owner_address));
        slice domain_address = in_msg_body~load_msg_addr();
        transfer_nft(query_id, domain_address, storage::owner_address, storage::owner_address, 0, mode::CARRY_REMAINING_BALANCE, 0, null());
        return ();
    }

    throw(exc::UNSUPPORTED_OP);
}


;; Get methods

(slice, int, cell, int, int, int) get_storage_data() method_id {
    (slice storage::owner_address, int storage::state, 
     cell storage::domains_dict, int storage::commission, int storage::domains_left) = load_data();
    
    return (storage::owner_address, storage::state, storage::domains_dict, storage::commission, storage::domains_left, cell_hash(my_code()));
}
