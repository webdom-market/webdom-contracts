#include "../global_imports/all_imports.fc";
#include "constants.fc";


const int tons::MIN_TON_FOR_STORAGE = 44000000;  ;; 0.044 TON


global slice storage::seller_address;         ;; MsgAddress
global cell  storage::domains_dict;           ;; HashmapE: DomainAddress(MsgAddress) -> {expired?(Bool), received?(Bool)}
global int   storage::domains_total;          ;; uint8
global int   storage::domains_received;       ;; uint8

global int   storage::price;                  ;; Coins
global int   storage::commission;             ;; Coins

global int   storage::state;                  ;; uint2 (0 - uninit, 1 - active, 2 - completed, 3 - cancelled)
global int   storage::created_at;             ;; uint32
global int   storage::last_renewal_time;      ;; uint32
global int   storage::valid_until;            ;; uint32

global int   storage::tons_to_reserve;        ;; uint32
global slice storage::buyer_address;          ;; MsgAddress

global slice storage::jetton_minter_address;  ;; MsgAddress
global slice storage::jetton_wallet_address;  ;; MsgAddress

global int   storage::hot_until;              ;; uint32
global int   storage::colored_until;          ;; uint32


() load_data() impure {
    slice ds = get_data().begin_parse();  ;; Bits = 267 + 1 + 8 + 8 + 124 + 124 + 2 + 32 + 32 + 32 + 32 + 267 + 32 + 32 = 993

    storage::seller_address    = ds~load_msg_addr();
    storage::domains_dict      = ds~load_dict();
    storage::domains_total     = ds~load_uint(8);
    storage::domains_received  = ds~load_uint(8);

    storage::price             = ds~load_coins();
    storage::commission        = ds~load_coins();
    
    storage::state             = ds~load_uint(2);
    storage::created_at        = ds~load_uint(32);
    storage::last_renewal_time = ds~load_uint(32);
    storage::valid_until       = ds~load_uint(32);

    storage::tons_to_reserve   = ds~load_uint(32);
    storage::buyer_address     = ds~load_msg_addr();

    storage::hot_until         = ds~load_uint(32);
    storage::colored_until     = ds~load_uint(32);
    
    slice ds2 = ds~load_ref().begin_parse();
    storage::jetton_minter_address = ds2~load_msg_addr();
    storage::jetton_wallet_address = ds2~load_msg_addr();
    ds2.end_parse();

    ds.end_parse();
}


#include "../global_imports/admin_functions.fc";  
#include "../global_imports/handle_promotion.fc";

() save_data() impure {
    set_data(
        begin_cell()
            .store_slice(storage::seller_address)
            .store_dict(storage::domains_dict)
            .store_uint(storage::domains_total, 8)
            .store_uint(storage::domains_received, 8)

            .store_coins(storage::price)
            .store_coins(storage::commission)
            
            .store_uint(storage::state, 2)
            .store_uint(storage::created_at, 32)
            .store_uint(storage::last_renewal_time, 32)
            .store_uint(storage::valid_until, 32)
            
            .store_uint(storage::tons_to_reserve, 32)
            .store_slice(storage::buyer_address)
            
            .store_uint(storage::hot_until, 32)
            .store_uint(storage::colored_until, 32)
            
            .store_ref(
                begin_cell()
                    .store_slice(storage::jetton_minter_address)
                    .store_slice(storage::jetton_wallet_address)
                .end_cell()
            )
        .end_cell()
    );
}

() cancel_sale(int query_id) impure inline {
    (slice domain_address, slice domain_info, int found?) = storage::domains_dict.dict_get_min?(267);
    while (found?) {
        if (domain_info~load_int(1)) {
            transfer_nft(query_id, domain_address, storage::seller_address, storage::seller_address, 
                            tons::NFT_TRANSFER, mode::SIMPLE, 1, null());
        }
        (domain_address, domain_info, found?) = storage::domains_dict.dict_get_next?(267, domain_address);
    }

    storage::state = state::CANCELLED;
    storage::valid_until = now();
    save_data();
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    force_same_workchain(sender_address);

    load_data();
    if (flags & 1) {  ;; bounced messages
        send_excess(storage::seller_address, 0, 0, mode::CARRY_REMAINING_GAS);
        return ();
    }

    int op = 0;
    int query_id = 0;
    if (in_msg_body.slice_bits()) {
        op = in_msg_body~load_uint(32);
    }
    if (op != 0) {
        query_id = in_msg_body~load_uint(64);
    }
    elseif (equal_slices(in_msg_body, msg::CANCEL_MESSAGE)) {
        op = op::CANCEL_DEAL;
    }
    elseif (equal_slices(in_msg_body, msg::RENEW_DOMAIN_MESSAGE)) {
        op = op::RENEW_DOMAIN;
    }
    elseif (equal_slices(in_msg_body, msg::FILL_UP_BALANCE_MESSAGE)) {
        op = op::FILL_UP_BALANCE;
    }

    int now_time = now();
    int purchase_available = (storage::domains_received == storage::domains_total) & (storage::state == state::ACTIVE) & (storage::valid_until > now_time);
    handle_admin_message(op, sender_address, in_msg_body, msg_value, ~ purchase_available, ~ purchase_available);

    ;; Fill up balance or deploy
    if (op == op::FILL_UP_BALANCE) {
        if (storage::state == state::UNINIT) {
            throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, MARKETPLACE_ADDRESS));
            get_jetton_wallet_address(storage::jetton_minter_address, mode::CARRY_REMAINING_GAS);
            return ();
        }
        return ();
    }

    if (op == op::TAKE_WALLET_ADDRESS) {
        throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::jetton_minter_address));
        throw_unless(exc::ALREADY_DEPLOYED, storage::state == state::UNINIT);
        storage::jetton_wallet_address = in_msg_body~load_msg_addr();
        storage::state = state::ACTIVE;
        save_data();
        return ();
    }

    ;; Initial domains transfer
    if (op == op::OWNERSHIP_ASSIGNED) {
        slice from_address = in_msg_body~load_msg_addr();
        try {
            (_, int found?) = storage::domains_dict.dict_get?(267, sender_address);
            throw_unless(exc::INCORRECT_DOMAIN, found?);
            
            storage::domains_dict~dict_set(267, sender_address, BIT_TRUE_SLICE());
            storage::domains_received += 1;

            if (storage::domains_received == storage::domains_total) {
                storage::tons_to_reserve = (tons::NFT_TRANSFER + 7500000) * storage::domains_total + tons::MIN_TON_FOR_STORAGE;
                if (my_balance - 20000000 < storage::tons_to_reserve) { 
                    storage::tons_to_reserve = tons::MIN_TON_FOR_STORAGE;  ;; disable cancellation by external message if balance is not enough
                }
                raw_reserve(storage::tons_to_reserve, 0);
                send_message_with_comment(storage::seller_address, 0, "Multiple sale on webdom.market is active", mode::CARRY_REMAINING_BALANCE);
            }
            
            save_data();
            return ();
        } 
        catch (_, n) {
            ;; Try to return the domain back to the sender in case of error
            raw_reserve(max(storage::tons_to_reserve, my_balance - msg_value - 7000000), 0);
            transfer_nft(query_id, sender_address, from_address, from_address, 0, mode::CARRY_REMAINING_BALANCE, 1,
                         payload_with_comment("Error, code ").store_number10(n).end_cell());
                         
            commit();
            throw(n);
            
            return ();
        }
    }

    ;; Domain expiration notification
    if (op == op::DNS_BALANCE_RELEASE) {
        (_, int found?) = storage::domains_dict.dict_get?(267, sender_address);
        throw_unless(exc::INCORRECT_DOMAIN, found?);
        accept_message();
        if (storage::state != state::CANCELLED) {
            storage::domains_dict~dict_set(267, sender_address, BIT_FALSE_SLICE());
            cancel_sale(query_id);
        }
        send_message_with_comment(storage::seller_address, 0, "Your domain has expired", mode::CARRY_REMAINING_BALANCE);
        return ();
    }
    
    if (op == op::DEDUST_PAYOUT) {
        op = 0;
        sender_address = in_msg_body~load_maybe_ref().begin_parse();
    }

    return_tons_if_condition(sender_address, exc::DEAL_NOT_ACTIVE, storage::state != state::ACTIVE);  ;; check that the sale is active
    
    ;; Purchase
    if (op == op::TRANSFER_NOTIFICATION) {
        int   transferred_jettons = in_msg_body~load_coins();
        slice from_address        = in_msg_body~load_msg_addr();
        
        ;; if jettons were received by dedust swap
        slice payload = in_msg_body~load_int(1) ? in_msg_body~load_ref().begin_parse() : in_msg_body;
        if (slice_bits(payload) == 267) {
            from_address = payload~load_msg_addr();
        }

        try {
            throw_unless(exc::DEAL_NOT_ACTIVE, purchase_available);  ;; check that the sale is active
            throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::jetton_wallet_address));
            throw_unless(exc::OUT_OF_GAS, msg_value >= tons::TON_SIMPLE_PURCHASE * storage::domains_total + tons::JETTON_MULTIPLE_PURCHASE);
            throw_unless(exc::NOT_ENOUGH_JETTONS, transferred_jettons >= storage::price);

            int excesses = transferred_jettons - storage::price;
            if (excesses > 0) {
                ;; send excesses to buyer
                send_jettons(query_id, excesses, from_address, from_address, storage::jetton_wallet_address,
                             tons::JETTON_TRANSFER, mode::SIMPLE, 1, EXCESSES_NOTIFICATION());
            }

            if (storage::commission) { 
                ;; send marketplace commission
                send_jettons(query_id, storage::commission, MARKETPLACE_ADDRESS, from_address, storage::jetton_wallet_address, tons::JETTON_TRANSFER + tons::NOTIFY_MARKETPLACE,
                            mode::SIMPLE, tons::NOTIFY_MARKETPLACE, MARKETPLACE_COMMISSION_NOTIFICATION());
            }

            ;; send domains
            (slice domain_address, _, int found?) = storage::domains_dict.dict_get_min?(267);
            while (found?) {
                transfer_nft(query_id, domain_address, from_address, from_address, tons::PURCHASE_NOTIFICATION + tons::NFT_TRANSFER, mode::SIMPLE, tons::PURCHASE_NOTIFICATION, BUYER_NOTIFICATION());  ;; domain transfer
                (domain_address, _, found?) = storage::domains_dict.dict_get_next?(267, domain_address);
            }

            ;; send seller payout
            send_jettons(query_id, storage::price - storage::commission, storage::seller_address, storage::seller_address, storage::jetton_wallet_address, tons::JETTON_TRANSFER,
                         mode::CARRY_REMAINING_BALANCE, 1, MULTIPLE_SALE_NOTIFICATION());

            storage::state = state::COMPLETED;
            storage::valid_until = now_time;
            storage::buyer_address = from_address;
            save_data();

            return ();
        }
        catch (_, n) { ;; if something went wrong contract tries to return jettons back with corresponding error code as a comment
            raw_reserve(max(storage::tons_to_reserve, my_balance - msg_value - 7000000), 0);
            send_jettons(query_id, transferred_jettons, from_address, from_address, sender_address, 0, mode::CARRY_REMAINING_BALANCE,
                           1, payload_with_comment("Error. Code ").store_number10(n).end_cell());  

            commit();
            throw(n);

            return ();
        }
    }

    ;; Cancel sale
    if (op == op::CANCEL_DEAL) {
        throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::seller_address) | equal_slices(sender_address, ADMIN_ADDRESS));
        accept_message();
        cancel_sale(query_id);
        send_message_with_comment(storage::seller_address, 0, "Sale cancelled", mode::CARRY_REMAINING_BALANCE);
        return ();
    }

    ;; Change price
    if (op == op::CHANGE_PRICE) { 
        throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::seller_address));

        int new_price = in_msg_body~load_coins();
        int new_commission = muldiv(new_price, storage::commission, storage::price);
        int new_valid_until = in_msg_body~load_uint(32);
        throw_unless(exc::INCORRECT_VALID_UNTIL, (new_valid_until >= max(now_time + 600, storage::valid_until)) & 
                                                 (new_valid_until <= storage::last_renewal_time + ONE_YEAR - ONE_DAY));

        storage::valid_until = new_valid_until;
        storage::price = new_price;
        storage::commission = new_commission;
        save_data();

        raw_reserve(max(storage::tons_to_reserve, my_balance - msg_value - 7000000), 0);
        cell payload = payload_with_comment("Price changed to ").store_str_jettons(new_price, ONE_TON, "TON").end_cell();
        send_cell_message(sender_address, 0, payload, mode::CARRY_REMAINING_BALANCE);

        return ();
    }

    ;; Renew domains
    if (op == op::RENEW_DOMAIN) {
        throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::seller_address));
        throw_unless(exc::OUT_OF_GAS, msg_value >= tons::RENEW_REQUEST + tons::RENEW_DOMAIN * storage::domains_total);
        throw_unless(exc::DOMAIN_EXPIRED, storage::last_renewal_time + ONE_YEAR - ONE_DAY >= now_time);  ;; check that domain expires later than in one day
        
        raw_reserve(max(storage::tons_to_reserve, my_balance - msg_value - 7000000), 0);
        (slice domain_address, _, int found?) = storage::domains_dict.dict_get_min?(267);
        while (found?) {
            send_cell_message(domain_address, tons::RENEW_DOMAIN, null(), mode::PAY_FEES_SEPARATELY);
            (domain_address, _, found?) = storage::domains_dict.dict_get_next?(267, domain_address);
        }
        send_builder_message(MARKETPLACE_ADDRESS, 0, begin_cell().store_uint(op::RENEWAL_FEE, 32).store_uint(query_id, 64), mode::CARRY_REMAINING_BALANCE);

        int new_valid_until = in_msg_body.slice_bits() ? min(now_time + ONE_YEAR - ONE_DAY, in_msg_body~load_uint(32)) : now_time + ONE_YEAR - ONE_DAY;
        throw_unless(exc::INCORRECT_VALID_UNTIL, new_valid_until >= max(now_time + ONE_HOUR, storage::valid_until));
        storage::valid_until = new_valid_until;
        save_data();

        return ();
    }

    if ((op == op::MAKE_COLORED) | (op == op::MAKE_HOT)) {
        int promotion_until = in_msg_body~load_uint(32);
        handle_promotion(promotion_until, op, query_id, sender_address);
        save_data();
        return ();
    }
    
    ;; need to return TONs in case of dedust swap
    raw_reserve(max(storage::tons_to_reserve, my_balance - msg_value - 7000000), 0);
    send_message_with_comment(sender_address, 0, "Unsupported op", mode::CARRY_REMAINING_BALANCE);
    commit();
    throw(exc::UNSUPPORTED_OP);
}


() recv_external(slice in_msg_body) impure {
    load_data();

    throw_if(exc::DEAL_NOT_ACTIVE, storage::state != state::ACTIVE);

    if (now() >= storage::valid_until) {
        throw_if(exc::UNSUPPORTED_OP, in_msg_body~load_uint(32) != op::CANCEL_DEAL);
        accept_message();
        
        cancel_sale(in_msg_body~load_uint(64));
        send_message_with_comment(storage::seller_address, 0, "Your sale offer has expired", mode::CARRY_REMAINING_BALANCE);

        storage::state = state::CANCELLED;
        save_data();
        return ();
    }

    throw(0xfffe);
}

;; Get methods

(slice, cell, int, int, int, int, int, int, int, int, slice, int, slice, int, int, slice, int) get_storage_data() method_id {
    load_data();
    return (
        storage::seller_address,
        storage::domains_dict,
        storage::domains_total,
        storage::domains_received,
        storage::state,
        storage::price,
        muldiv(storage::commission, COMMISSION_DIVIDER, storage::price),
        storage::created_at,
        storage::last_renewal_time,
        storage::valid_until,
        storage::buyer_address,
        storage::tons_to_reserve,

        storage::jetton_wallet_address,

        storage::hot_until,
        storage::colored_until,

        storage::jetton_minter_address, 
        cell_hash(my_code())
    );
}


_ get_fix_price_data_v4() method_id {
    load_data();
    (slice domain_address, _, _) = storage::domains_dict.dict_get_min?(267); 
    (_, int jetton_wallet_int) = parse_std_addr(storage::jetton_wallet_address);
    cell jetton_price_dict = new_dict();
    jetton_price_dict~udict_set_builder(256, jetton_wallet_int, begin_cell().store_coins(storage::price));
    return (
        storage::state > state::ACTIVE,
        storage::created_at,
        MARKETPLACE_ADDRESS,
        domain_address,
        storage::seller_address,
        0,
        MARKETPLACE_ADDRESS,
        muldiv(storage::commission, COMMISSION_DIVIDER * 10, storage::price),
        BURN_ADDRESS,
        0,
        ((storage::valid_until > now()) | (storage::state != state::COMPLETED)) ? 0 : storage::valid_until,
        0,
        jetton_price_dict
    );
}
