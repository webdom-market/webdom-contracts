#include "constants.fc";


(int) deploy_ton_simple_sale(slice seller_address, slice payload, slice deploy_info, 
                             slice domain_address, slice domain_name, cell ton_fix_price_code, 
                             int commission_discount, int query_id, slice domain_zone) impure inline {
    int min_price         = deploy_info~load_coins();
    int commission_factor = deploy_info~load_uint(16);
    int max_commission    = deploy_info~load_coins();
    int min_duration      = deploy_info~load_uint(32);

    int price       = payload~load_coins();
    int valid_until = payload~load_uint(32);
    throw_unless(exc::PRICE_TOO_LOW, price >= min_price);
    throw_unless(exc::INCORRECT_VALID_UNTIL, (valid_until >= now() + min_duration) & (valid_until <= now() + ONE_YEAR - ONE_DAY));  ;; min 10 minutes, max 1 year
    
    int commission = muldiv(min(muldiv(price, commission_factor, COMMISSION_DIVIDER), max_commission), COMMISSION_DIVIDER - commission_discount, COMMISSION_DIVIDER);
    cell data = begin_cell()
                .store_slice(domain_address)
                .store_slice(seller_address)
                .store_coins(price)
                .store_uint(state::UNINIT, 2)
                .store_coins(commission)
                .store_uint(now(), 32)  ;; created_at
                .store_uint(now(), 32)  ;; last_renewal_time
                .store_uint(valid_until, 32)
                .store_uint(0, 1)       ;; buyer_address
                .store_ref(             ;; payout_notification
                    payload_with_comment("Your domain ").store_slice(domain_name).store_slice(domain_zone).store_slice(" was sold on webdom.market").end_cell()
                )
                .store_uint(0, 64)  ;; hot_until & colored_until
            .end_cell();
    cell state_init = pack_state_init(ton_fix_price_code, data);
    slice sale_address = get_address_by_state_init(state_init);
    
    int required_gas = tons::NFT_TRANSFER;
    transfer_nft(0, domain_address, sale_address, TWO_ZEROS_SLICE(), required_gas, mode::SIMPLE, 0, null());
    cell msg_body = begin_cell().store_uint(op::FILL_UP_BALANCE, 32).store_uint(query_id, 64).end_cell();
    required_gas += send_deploy_message(sale_address, tons::DEPLOY_TON_SIMPLE_SALE, state_init, msg_body, mode::PAY_FEES_SEPARATELY);

    return required_gas + tons::DEPLOY_TON_SIMPLE_SALE;
}


(int) deploy_jetton_simple_sale(slice seller_address, slice payload, slice deploy_info, 
                                slice domain_address, slice domain_name, cell jetton_simple_sale_code, 
                                int commission_discount, int query_id, slice domain_zone) impure inline {
    int is_web3 = payload~load_int(1);
    if (is_web3) {
        deploy_info = deploy_info~load_ref().begin_parse();
        if (commission_discount) {
            commission_discount = COMMISSION_DIVIDER;
        }
    }
    int min_price         = deploy_info~load_coins();
    int commission_factor = deploy_info~load_uint(16);
    int max_commission    = deploy_info~load_coins();
    int min_duration      = deploy_info~load_uint(32);

    int price       = payload~load_coins();
    int valid_until = payload~load_uint(32);
    throw_unless(exc::PRICE_TOO_LOW, price >= min_price);
    throw_unless(exc::INCORRECT_VALID_UNTIL, (valid_until >= now() + min_duration) & (valid_until <= now() + ONE_YEAR - ONE_DAY));  ;; min 10 minutes, max 1 year
    
    int commission = muldiv(min(muldiv(price, commission_factor, COMMISSION_DIVIDER), max_commission), COMMISSION_DIVIDER - commission_discount, COMMISSION_DIVIDER);
    cell data = begin_cell()
                .store_slice(domain_address)
                .store_slice(seller_address)
                .store_uint(0, 2)
                .store_coins(price)
                .store_uint(state::UNINIT, 2)
                .store_ref(
                    begin_cell()
                        .store_slice(is_web3 ? WEB3_ADDRESS : USDT_ADDRESS)
                        .store_coins(commission)
                        .store_uint(now(), 32)  ;; created_at
                        .store_uint(now(), 32)  ;; last_renewal_time
                        .store_uint(valid_until, 32)
                        .store_uint(0, 1)       ;; buyer_address
                        .store_ref(             ;; payout_notification
                            payload_with_comment("Your domain ").store_slice(domain_name).store_slice(domain_zone).store_slice(" was sold on webdom.market").end_cell()
                        )
                        .store_uint(0, 64)  ;; hot_until & colored_until
                    .end_cell()
                )
            .end_cell();
    cell state_init = pack_state_init(jetton_simple_sale_code, data);
    slice sale_address = get_address_by_state_init(state_init);
    
    int required_gas = tons::NFT_TRANSFER;
    transfer_nft(0, domain_address, sale_address, TWO_ZEROS_SLICE(), required_gas, mode::SIMPLE, 0, null());
    cell msg_body = begin_cell().store_uint(op::FILL_UP_BALANCE, 32).store_uint(query_id, 64).end_cell();
    required_gas += send_deploy_message(sale_address, tons::DEPLOY_JETTON_SIMPLE_SALE, state_init, msg_body, mode::PAY_FEES_SEPARATELY);

    return required_gas + tons::DEPLOY_JETTON_SIMPLE_SALE;
}


(int) deploy_ton_multiple_sale(slice seller_address, slice payload, slice deploy_info, 
                                cell ton_multiple_sale_code, int commission_discount, int query_id) impure inline {
    int min_price         = deploy_info~load_coins();
    int commission_factor = deploy_info~load_uint(16);
    int max_commission    = deploy_info~load_coins();
    int min_duration      = deploy_info~load_uint(32);

    cell domains_list = payload~load_dict();  ;; HashmapE; Index(uint8) -> DomainName(string)
    int price         = payload~load_coins();
    int valid_until   = payload~load_uint(32);
    throw_unless(exc::PRICE_TOO_LOW, price >= min_price);
    throw_unless(exc::INCORRECT_VALID_UNTIL, (valid_until >= now() + min_duration) & (valid_until <= now() + ONE_YEAR - ONE_DAY));  ;; min 10 minutes, max 1 year

    int domains_total = 0;
    cell domains_dict = new_dict();
    (int ind, slice domain_name, int found?) = domains_list.udict_get_min?(8);
    while (found?) {
        int is_tg_username = domain_name~load_int(1);
        domains_total += 1;
        domains_dict~dict_set(267, is_tg_username ? tg_username_to_address(domain_name) : domain_name_to_address(domain_name), TWO_ZEROS_SLICE());
        (ind, domain_name, found?) = domains_list.udict_get_next?(8, ind);
    }
    throw_unless(exc::EMPTY_DICT, domains_total > 0);

    int commission = muldiv(min(muldiv(price, commission_factor, COMMISSION_DIVIDER), max_commission), COMMISSION_DIVIDER - commission_discount, COMMISSION_DIVIDER);
    cell data = begin_cell()
                .store_slice(seller_address)
                .store_dict(domains_dict)
                .store_uint(domains_total, 8)
                .store_uint(0, 8)               ;; domains_received

                .store_coins(price)
                .store_coins(commission)

                .store_uint(state::UNINIT, 2)
                .store_uint(now(), 32)          ;; created_at
                .store_uint(now(), 32)          ;; last_renewal_time
                .store_uint(valid_until, 32)

                .store_uint(15000000, 32)       ;; tons_to_reserve
                .store_uint(0, 66)              ;; buyer_address, hot_until, colored_until
            .end_cell();
    cell state_init = pack_state_init(ton_multiple_sale_code, data);
    slice sale_address = get_address_by_state_init(state_init);
    
    cell msg_body = begin_cell().store_uint(op::FILL_UP_BALANCE, 32).store_uint(query_id, 64).end_cell();
    int required_gas = tons::DEPLOY_TON_MULTIPLE_SALE;
    required_gas += send_deploy_message(sale_address, required_gas, state_init, msg_body, mode::PAY_FEES_SEPARATELY);

    return required_gas;
}


(int) deploy_jetton_multiple_sale(slice seller_address, slice payload, slice deploy_info, 
                                  cell jetton_multiple_sale_code, int commission_discount, int query_id) impure inline {
    int is_web3 = payload~load_int(1);
    if (is_web3) {
        deploy_info = deploy_info~load_ref().begin_parse();
        if (commission_discount) {
            commission_discount = COMMISSION_DIVIDER;
        }
    }
    int min_price         = deploy_info~load_coins();
    int commission_factor = deploy_info~load_uint(16);
    int max_commission    = deploy_info~load_coins();
    int min_duration      = deploy_info~load_uint(32);
    
    cell domains_list = payload~load_dict();  ;; HashmapE; Index(uint8) -> DomainName(string)
    int price         = payload~load_coins();
    int valid_until   = payload~load_uint(32);
    throw_unless(exc::PRICE_TOO_LOW, price >= min_price);
    throw_unless(exc::INCORRECT_VALID_UNTIL, (valid_until >= now() + min_duration) & (valid_until <= now() + ONE_YEAR - ONE_DAY));  ;; min 10 minutes, max 1 year

    int domains_total = 0;
    cell domains_dict = new_dict();
    (int ind, slice domain_name, int found?) = domains_list.udict_get_min?(8);
    while (found?) {
        int is_tg_username = domain_name~load_int(1);
        domains_total += 1;
        domains_dict~dict_set(267, is_tg_username ? tg_username_to_address(domain_name) : domain_name_to_address(domain_name), TWO_ZEROS_SLICE());
        (ind, domain_name, found?) = domains_list.udict_get_next?(8, ind);
    }
    throw_unless(exc::EMPTY_DICT, domains_total > 0);

    int commission = muldiv(min(muldiv(price, commission_factor, COMMISSION_DIVIDER), max_commission), COMMISSION_DIVIDER - commission_discount, COMMISSION_DIVIDER);
    cell data = begin_cell()
                .store_slice(seller_address)
                .store_dict(domains_dict)
                .store_uint(domains_total, 8)
                .store_uint(0, 8)               ;; domains_received

                .store_coins(price)
                .store_coins(commission)

                .store_uint(state::UNINIT, 2)
                .store_uint(now(), 32)          ;; created_at
                .store_uint(now(), 32)          ;; last_renewal_time
                .store_uint(valid_until, 32)

                .store_uint(15000000, 32)       ;; tons_to_reserve
                .store_uint(0, 66)              ;; buyer_address, hot_until, colored_until

                .store_ref(
                    begin_cell()
                        .store_slice(is_web3 ? WEB3_ADDRESS : USDT_ADDRESS)
                        .store_uint(0, 2)
                    .end_cell()
                )
            .end_cell();
            
    cell state_init = pack_state_init(jetton_multiple_sale_code, data);
    slice sale_address = get_address_by_state_init(state_init);
    
    cell msg_body = begin_cell().store_uint(op::FILL_UP_BALANCE, 32).store_uint(query_id, 64).end_cell();
    int required_gas = tons::DEPLOY_TON_MULTIPLE_SALE;
    required_gas += send_deploy_message(sale_address, required_gas, state_init, msg_body, mode::PAY_FEES_SEPARATELY);

    return required_gas;
}
