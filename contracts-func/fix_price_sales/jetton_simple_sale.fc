#include "../global_imports/all_imports.fc";
#include "constants.fc";


global slice storage::domain_address;
global slice storage::seller_address;
global slice storage::jetton_wallet_address;
global int   storage::price;
global int   storage::state;

global slice storage::jetton_minter_address;

global int   storage::commission;
global int   storage::created_at;
global int   storage::last_renewal_time;
global int   storage::valid_until;
global cell  storage::buyer_address_cell;
global cell  storage::payout_notification;
global int   storage::hot_until;
global int   storage::colored_until;


() load_data() impure {
    slice ds = get_data().begin_parse();  ;; Bits = 267 + 267 + 124 + 2 + 124 + 32 + 32 + 1 + 32 + 32 = 913; Refs = 2
    storage::domain_address        = ds~load_msg_addr();
    storage::seller_address        = ds~load_msg_addr();
    storage::jetton_wallet_address = ds~load_msg_addr();
    storage::price                 = ds~load_coins();
    storage::state                 = ds~load_uint(2);

    slice ds2 = ds~load_ref().begin_parse();
    storage::jetton_minter_address = ds2~load_msg_addr();
    storage::commission            = ds2~load_coins();
    storage::created_at            = ds2~load_uint(32);
    storage::last_renewal_time     = ds2~load_uint(32);
    storage::valid_until           = ds2~load_uint(32);
    storage::buyer_address_cell    = ds2~load_maybe_ref();
    storage::payout_notification   = ds2~load_ref();
    storage::hot_until             = ds2~load_uint(32);
    storage::colored_until         = ds2~load_uint(32);

    ds2.end_parse();
    ds.end_parse();
}

#include "../global_imports/admin_functions.fc";  
#include "../global_imports/handle_promotion.fc";

() save_data() impure inline {
    set_data(
        begin_cell()
            .store_slice(storage::domain_address)
            .store_slice(storage::seller_address)
            .store_slice(storage::jetton_wallet_address)
            .store_coins(storage::price)
            .store_uint(storage::state, 2)
            .store_ref(
                begin_cell()
                    .store_slice(storage::jetton_minter_address)
                    .store_coins(storage::commission)
                    .store_uint(storage::created_at, 32)
                    .store_uint(storage::last_renewal_time, 32)
                    .store_uint(storage::valid_until, 32)
                    .store_maybe_ref(storage::buyer_address_cell)
                    .store_ref(storage::payout_notification)
                    .store_uint(storage::hot_until, 32)
                    .store_uint(storage::colored_until, 32)
                .end_cell()
            )
        .end_cell()
    );
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    force_same_workchain(sender_address);

    load_data();
    
    if (flags & 1) {  ;; bounced messages
        return ();
    }

    int op = 0;
    int query_id = 0;
    if (in_msg_body.slice_bits()) {
        op = in_msg_body~load_uint(32);
    }
    if (op != 0) {
        query_id = in_msg_body~load_uint(64);
    }
    elseif (equal_slices(in_msg_body, msg::CANCEL_MESSAGE)) {
        op = op::CANCEL_DEAL;
    }
    elseif (equal_slices(in_msg_body, msg::RENEW_DOMAIN_MESSAGE)) {
        op = op::RENEW_DOMAIN;
    }
    elseif (equal_slices(in_msg_body, msg::FILL_UP_BALANCE_MESSAGE)) {
        op = op::FILL_UP_BALANCE;
    }

    handle_admin_message(op, sender_address, in_msg_body, msg_value, storage::state != state::ACTIVE, storage::state != state::COMPLETED);
    int now_time = now();
    ;; Fill up balance or deploy
    if (op == op::FILL_UP_BALANCE) {
        if (storage::state == state::UNINIT) {
            throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, MARKETPLACE_ADDRESS));
            get_jetton_wallet_address(storage::jetton_minter_address, mode::CARRY_REMAINING_GAS);
            return ();
        }
        return ();
    }

    if (op == op::TAKE_WALLET_ADDRESS) {
        throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::jetton_minter_address));
        throw_unless(exc::ALREADY_DEPLOYED, storage::state == state::UNINIT);
        storage::jetton_wallet_address = in_msg_body~load_msg_addr();
        storage::state = state::ACTIVE;
        save_data();
        return ();
    }

    ;; Domain expiration notification
    if (op == op::DNS_BALANCE_RELEASE) {
        throw_unless(exc::INCORRECT_DOMAIN, equal_slices(sender_address, storage::domain_address));
        
        send_message_with_comment(storage::seller_address, 0, "Your domain has expired", mode::CARRY_REMAINING_BALANCE);
        
        storage::state = state::CANCELLED;
        if (storage::valid_until > now_time) {
            storage::valid_until = now_time;
        }
        save_data();
        return ();
    }

    ;; Purchase
    if (op == op::TRANSFER_NOTIFICATION) {
        int   transferred_jettons = in_msg_body~load_coins();
        slice from_address        = in_msg_body~load_msg_addr();
        
        ;; if jettons were received by dedust swap
        slice payload = in_msg_body~load_int(1) ? in_msg_body~load_ref().begin_parse() : in_msg_body;
        if (slice_bits(payload) == 267) {
            from_address = payload~load_msg_addr();
        }

        try {
            throw_unless(exc::DEAL_NOT_ACTIVE, storage::state == state::ACTIVE);  ;; check that the sale is active
            throw_unless(exc::DOMAIN_EXPIRED, storage::valid_until > now_time);  ;; check that deal is not expired
            throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::jetton_wallet_address));
            throw_unless(exc::OUT_OF_GAS, msg_value >= tons::JETTON_SIMPLE_PURCHASE);
            throw_unless(exc::NOT_ENOUGH_JETTONS, transferred_jettons >= storage::price);

            int excesses = transferred_jettons - storage::price;
            if (excesses > 0) {
                ;; send excesses to buyer
                send_jettons(query_id, excesses, from_address, from_address, storage::jetton_wallet_address,
                             tons::JETTON_TRANSFER, mode::SIMPLE, 1, EXCESSES_NOTIFICATION());
            }
            if (storage::commission) {
                ;; send marketplace commission
                send_jettons(query_id, storage::commission, MARKETPLACE_ADDRESS, from_address, storage::jetton_wallet_address, tons::JETTON_TRANSFER + tons::NOTIFY_MARKETPLACE,
                            mode::SIMPLE, tons::NOTIFY_MARKETPLACE, MARKETPLACE_COMMISSION_NOTIFICATION());
            }
            ;; send seller payout
            send_jettons(query_id, storage::price - storage::commission, storage::seller_address, storage::seller_address, storage::jetton_wallet_address, tons::JETTON_TRANSFER,
                         mode::SIMPLE, 1, storage::payout_notification);
            ;; transfer domain to buyer
            transfer_nft(query_id, storage::domain_address, from_address, from_address, 0, mode::CARRY_REMAINING_BALANCE, tons::PURCHASE_NOTIFICATION, BUYER_NOTIFICATION());  ;; domain transfer

            storage::state = state::COMPLETED;
            storage::valid_until = now_time;
            storage::buyer_address_cell = begin_cell().store_slice(from_address).end_cell();
            save_data();
        
            return ();
        }
        catch (_, n) { ;; if something went wrong contract tries to return jettons back with corresponding error code as a comment
            raw_reserve(storage_fees(), 4);
            send_jettons(query_id, transferred_jettons, from_address, from_address, sender_address, 0, mode::CARRY_REMAINING_BALANCE,
                           1, payload_with_comment("Error. Code ").store_number10(n).end_cell());  

            commit();
            throw(n);

            return ();
        }
    }

    if (op == op::EXCESSES) {
        slice recipient = storage::seller_address;
        if (storage::state == state::COMPLETED) {
            recipient = storage::buyer_address_cell.begin_parse();
        }
        raw_reserve(storage_fees(), 4);
        send_excess(recipient, query_id, 0, mode::CARRY_REMAINING_BALANCE);
        return ();
    }
    throw_unless(exc::DEAL_NOT_ACTIVE, storage::state == state::ACTIVE);  ;; check that the sale is active

    ;; Cancel sale (available even if valid_until < now_time, because it is possible to renew the domain after the expiration date)
    if (op == op::CANCEL_DEAL) {
        throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::seller_address) | equal_slices(sender_address, ADMIN_ADDRESS));
        transfer_nft(query_id, storage::domain_address, storage::seller_address, storage::seller_address, 
                    0, mode::CARRY_REMAINING_BALANCE, 1, SALE_CANCEL_NOTIFICATION());

        storage::state = state::CANCELLED;
        if (storage::valid_until > now_time) {
            storage::valid_until = now_time;
        }
        save_data();

        return ();
    }

    ;; Change price
    if (op == op::CHANGE_PRICE) { 
        throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::seller_address));

        int new_price = in_msg_body~load_coins();
        int new_commission = muldiv(new_price, storage::commission, storage::price);
        int new_valid_until = in_msg_body~load_uint(32);
        throw_unless(exc::INCORRECT_VALID_UNTIL, (new_valid_until >= max(now_time + 600, storage::valid_until)) & 
                                                 (new_valid_until <= storage::last_renewal_time + ONE_YEAR - ONE_DAY));

        storage::price = new_price;
        storage::commission = new_commission;
        storage::valid_until = new_valid_until;
        save_data();

        raw_reserve(storage_fees(), 4);
        slice symbol = "USDT";
        int one_coin = 1000000;
        if (equal_slices(storage::jetton_minter_address, WEB3_ADDRESS)) {
            symbol = "WEB3";
            one_coin = 1000;
        }
        cell payload = payload_with_comment("Price changed to ").store_str_jettons(new_price, one_coin, symbol).end_cell();
        send_cell_message(sender_address, 0, payload, mode::CARRY_REMAINING_BALANCE);

        return ();
    }

    ;; Renew the domain
    if (op == op::RENEW_DOMAIN) {
        throw_unless(exc::INCORRECT_SENDER, equal_slices(sender_address, storage::seller_address));
        throw_unless(exc::OUT_OF_GAS, msg_value >= tons::RENEW_REQUEST + tons::RENEW_DOMAIN);
        throw_unless(exc::DOMAIN_EXPIRED, storage::last_renewal_time + ONE_YEAR - ONE_DAY >= now_time);  ;; check that domain expires later than in 2 days

        raw_reserve(storage_fees(), 4);
        send_cell_message(storage::domain_address, tons::RENEW_DOMAIN, null(), mode::PAY_FEES_SEPARATELY);
        send_builder_message(MARKETPLACE_ADDRESS, 0, begin_cell().store_uint(op::RENEWAL_FEE, 32).store_uint(query_id, 64), mode::CARRY_REMAINING_BALANCE);
        
        int new_valid_until = in_msg_body.slice_bits() ? min(now_time + ONE_YEAR - ONE_DAY, in_msg_body~load_uint(32)) : now_time + ONE_YEAR - ONE_DAY;
        throw_unless(exc::INCORRECT_VALID_UNTIL, new_valid_until >= max(now_time + ONE_HOUR, storage::valid_until));
        storage::valid_until = new_valid_until;
        storage::last_renewal_time = now_time;
        save_data();
        
        return ();
    }

    if ((op == op::MAKE_COLORED) | (op == op::MAKE_HOT)) {
        int promotion_until = in_msg_body~load_uint(32);
        handle_promotion(promotion_until, op, query_id, sender_address);
        save_data();
        return ();
    }

    throw(exc::UNSUPPORTED_OP);
}


() recv_external(slice in_msg_body) impure {
    load_data();

    throw_if(exc::DEAL_NOT_ACTIVE, storage::state != state::ACTIVE);

    if (now() >= storage::valid_until) {
        throw_if(exc::UNSUPPORTED_OP, in_msg_body~load_uint(32) != op::CANCEL_DEAL);
        accept_message();

        transfer_nft(in_msg_body~load_uint(64), storage::domain_address, storage::seller_address,
                     storage::seller_address, 0, mode::CARRY_REMAINING_BALANCE, 1, SALE_CANCEL_NOTIFICATION());
        
        storage::state = state::CANCELLED;
        save_data();

        return ();
    }

    throw(0xfffe);
}


;; Get methods


(slice, cell, int, int, int, int, int, int, int, int, slice, cell, slice, int, int, slice, int) get_storage_data() method_id {
    load_data();
    
    cell domains_dict = new_dict();
    domains_dict~dict_set(267, storage::domain_address, BIT_TRUE_SLICE());
    slice buyer_address = cell_null?(storage::buyer_address_cell) ? TWO_ZEROS_SLICE() : storage::buyer_address_cell.begin_parse();
    return (
        storage::seller_address, 
        domains_dict, 
        1,
        1,
        storage::state, 
        storage::price, 
        muldiv(storage::commission, COMMISSION_DIVIDER, storage::price),
        storage::created_at,
        storage::last_renewal_time, 
        storage::valid_until, 
        buyer_address, 
        storage::payout_notification, 
        storage::jetton_wallet_address,

        storage::hot_until,
        storage::colored_until,
        
        storage::jetton_minter_address, 
        cell_hash(my_code()));
}


_ get_fix_price_data_v4() method_id {
    load_data();
    (_, int jetton_wallet_int) = parse_std_addr(storage::jetton_wallet_address);
    cell jetton_price_dict = new_dict();
    jetton_price_dict~udict_set_builder(256, jetton_wallet_int, begin_cell().store_coins(storage::price));
    return (
        storage::state > state::ACTIVE,
        storage::created_at,
        MARKETPLACE_ADDRESS,
        storage::domain_address,
        storage::seller_address,
        0,
        MARKETPLACE_ADDRESS,
        muldiv(storage::commission, COMMISSION_DIVIDER * 10, storage::price),
        BURN_ADDRESS,
        0,
        ((storage::valid_until > now()) | (storage::state != state::COMPLETED)) ? 0 : storage::valid_until,
        0,
        jetton_price_dict
    );
}
